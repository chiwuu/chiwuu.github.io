{"meta":{"title":"龍","subtitle":null,"description":null,"author":"龍","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2022-12-17T14:04:21.934Z","updated":"2022-12-17T14:04:21.934Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-02-13T14:52:12.381Z","updated":"2023-02-13T14:52:12.381Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"不关我事"},{"title":"所有标签","date":"2022-12-17T13:39:51.855Z","updated":"2022-12-17T13:39:51.855Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小程序海报生成","slug":"小程序海报生成","date":"2022-09-06T04:16:12.000Z","updated":"2023-02-14T14:41:19.934Z","comments":true,"path":"2022/09/06/小程序海报生成/","link":"","permalink":"http://example.com/2022/09/06/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%B7%E6%8A%A5%E7%94%9F%E6%88%90/","excerpt":"","text":"小程序的海报生成是使用canvas实现的，但是因为我对canvas并不熟悉，所以记录一下实现过程。 海报生成效果展示： 小程序海报生成实现，一般分为三个部分：背景绘制、图片绘制、文字绘制。 1、图片的绘制 图片绘制一般又分两种情况，一种是普通的图片绘制，另一种是图片经过剪裁后绘制，例如将正方形的用户头像裁剪称为圆形图案显示。 普通的图片绘制： 普通图片绘制需要注意的点是调用canvas.drawImage只能是绘制本地图片，如果绘制网络图片的话，会出现绘制空白的现象。解决的办法是使用**uni.downloadFile()**，这个api作用是将资源下载到本地。 因为绘制图片是异步的，且需要绘制多张图片，所以到时候使用**promise.all()**来保证每一张图都绘制完成。 1234567891011121314151617181920212223downfile(url)&#123;//下载网络图片的promise对象 return new Promise(function (resolve, reject) &#123; uni.downloadFile(&#123; url:url , success: function (res) &#123; resolve(res.tempFilePath) &#125; &#125;) &#125;)&#125;, /** * @param &#123;canvas对象&#125; ctx * @param &#123;图片源&#125; img * @param &#123;绘制初始X轴坐标&#125; startX * @param &#123;绘制初始Y轴坐标&#125; startY * @param &#123;绘制矩形X坐标&#125; drawX * @param &#123;绘制矩形Y坐标&#125; drawY */ drawImg(ctx,img,startX,startY,drawX,drawY)&#123; return this.downfile(img).then((value) =&gt; &#123; ctx.drawImage(value,startX,startY,drawX,drawY); &#125;)&#125;, 图片剪裁后绘制： 因为需要将用户头像绘制成圆形图案展示，即： 变成→ 因此，可以使用canvas.clip()来实现图片剪裁，但是clip()方法有个毛病，就是会将canvas剪裁区域外的东西都剪裁没了（区域外的东西还是会显示的，只是不能访问剪裁区域外了）ps：canvas.clip()这个方法其实并不是对图片进行剪裁，是对canvas对象进行剪裁，配合save()，restore()这两个方法从而实现图片剪裁。 canvas.save();会把当前状态推入栈中。直白点说就是将当前状态下的canvas画布进行一个存档。 canvas.arc(x坐标，y坐标，半径，2 * Math.PI);方法创建弧&#x2F;曲线（用于创建圆或部分圆）。 canvas.restore();会从栈中取出最顶部的状态。防止save后对Canvas执行的平移、放缩、旋转、错切、裁剪等可以改变画布的操作对后续的绘制的影响。 1234567891011121314151617181920 downfile(url)&#123;//下载网络图片的promise对象 return new Promise(function (resolve, reject) &#123; uni.downloadFile(&#123; url:url , success: function (res) &#123; resolve(res.tempFilePath) &#125; &#125;) &#125;) &#125;,pictureCut(ctx,img)&#123; return this.downfile(img).then((value)=&gt;&#123; ctx.save(); ctx.beginPath(); ctx.arc(45, 430, 30, 0, 2 * Math.PI);// ctx.clip(); ctx.drawImage(value, 15, 400, 60, 60); ctx.restore(); &#125;) &#125;, 2、文字绘制 文字绘制主要是处理文字的换行，canvas并不支持文字的换行，需要我们自己处理文字换行。canvas.measureText()这个api是在画布canvas输出文本前，检查字体的宽度。因此，可以使用这个api来检查文字是否超出容器宽度，从而决定是否换行。 123456789101112131415161718192021222324252627282930313233343536/** * canvas实现自动换行 * @param &#123;canvas对象&#125; ctx * @param &#123;描述&#125; canText * @param &#123;文本最大宽度,超过就换行&#125; MaxWidth * @param &#123;绘制文本X坐标&#125; startX * @param &#123;绘制文本Y坐标&#125; startY * @param &#123;行高&#125; lineHeight * @param &#123;字体大小&#125; fontSize * @param &#123;字体颜色&#125; fontColor */ wrapText(ctx,canText,MaxWidth,startX,startY,lineHeight,fontSize,fontColor)&#123; if (typeof canText != &#x27;string&#x27; || typeof startX != &#x27;number&#x27; || typeof startY != &#x27;number&#x27;) &#123; return; &#125; ctx.setFillStyle(fontColor);//文字颜色：默认黑色 ctx.setFontSize(fontSize);//设置字体大小，默认10 ctx.setTextAlign(&quot;left&quot;);// 设置位置 ctx.textBaseline = &#x27;middle&#x27;; // 字符分隔为数组 let arrText = canText.split(&#x27;&#x27;); let line = &#x27;&#x27;; for(let n = 0;n &lt; arrText.length; n++)&#123; let containerLine = line + arrText[n]; let containerLimit = ctx.measureText(containerLine); let containerWidth = containerLimit.width; if(containerWidth &gt; MaxWidth &amp;&amp; n &gt; 0)&#123; ctx.fillText(line, startX, startY); line = arrText[n]; startY += lineHeight; &#125; else &#123; line = containerLine; &#125; &#125; ctx.fillText(line, startX, startY); &#125;, 3、背景颜色绘制 因为有的图片是透明的，所以就需要绘制图片的背景颜色了，但是绘制多个颜色区域时，可能出现一个区域覆盖后绘制的区域这种情况。 解决办法是让绘制的区域分块，即用ctx.beginPath(),调用fill()进行填充。 1234567drawBackgroundColor(ctx,startX,startY,drawX,drawY,bc)&#123; ctx.beginPath() ctx.rect(startX, startY, drawX,drawY); ctx.setFillStyle(bc); ctx.fill(); ctx.closePath();&#125;, 另外，海报的生成展示我是通过uni.canvasToTempFilePath()来生成原canvas尺寸的图片大小，然后用image来进行展示。这样保存的图片会清晰一些吧（大概），因为我觉得直接用canvas来进行展示的话，canvas的比例是要小一些的，但是通过canvasToTempFilePath()生成比例大一些的图片时，图片可能会模糊一些。 下面是完整的实现过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268&lt;template&gt; &lt;view&gt; &lt;button @click=&quot;myDraw&quot;&gt;点击生成海报&lt;/button&gt; &lt;view class=&quot;mytest&quot; v-show=&quot;isShow&quot; @click=&quot;closePoster($event)&quot;&gt; &lt;canvas canvas-id=&quot;myCanvas&quot; id=&quot;myCanvas&quot; style=&quot;position: fixed;top: -10000px&quot; :style=&quot;&#123;&#x27;width&#x27;: viewWidth+&#x27;px&#x27;, &#x27;height&#x27;: viewHeight*0.8+&#x27;px&#x27;&#125;&quot;&gt;&lt;/canvas&gt; &lt;view class=&quot;posterBox&quot; @click.stop=&quot;() =&gt; &#123;&#125;&quot;&gt; &lt;image :src=&quot;poster&quot; mode=&quot;&quot; class=&quot;posterImg&quot;&gt;&lt;/image&gt; &lt;view class=&quot;btn&quot; @click=&quot;saveImg&quot;&gt;保存分享图&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; isShow:false, imgSrc:&quot;https://i.328888.xyz/2023/01/31/8Gdho.png&quot;, tabSrc:&quot;https://vkceyugu.cdn.bspapp.com/VKCEYUGU-dc2b4a8f-6ab2-47b5-b744-f0c5745aa5c0/ba781d6d-7ea4-4785-94f3-56ae31de5b45.png&quot;, newPrice:589, oldPrice:1299, info:null, viewWidth:&quot;&quot;, viewHeight:&quot;&quot;, goodDesc:&quot;敦煌研究院x哔哩哔哩 2233 敦煌伎乐天系列 高帮帆布鞋&quot;, userinfo:&#123;&#125;, opcCode:&#x27;../../static/opc.jpg&#x27;, poster:&#x27;&#x27; &#125; &#125;, methods: &#123; myDraw()&#123; this.getUserInfor().then((res)=&gt;&#123; // console.log(res); uni.showLoading(&#123; title: &#x27;加载中...&#x27; &#125;) this.userinfo = res; this.drawCanvas(); &#125;) &#125;, closePoster(e)&#123; // if(e.target.id === &quot;msk&quot;) this.isShow = !this.isShow; this.isShow = !this.isShow; &#125;, drawCanvas()&#123; let that = this; let ctx = uni.createCanvasContext(&quot;myCanvas&quot;,this); this.drawBackgroundColor(ctx,0,0,this.viewWidth,this.viewHeight * 0.8,&quot;white&quot;); //海报头图片绘制参数 let tabPicWidth = 300/375 * this.viewWidth * 0.5; let tabPicHeight = 130/603 * this.viewHeight * 0.5; let tabInitX = (this.viewWidth - tabPicWidth)/2; let tabInitY = this.viewHeight * 0.015; this.drawBackgroundColor(ctx,0,tabPicHeight+tabInitY*2,this.viewWidth,this.viewHeight * 0.35,&quot;#F1F1F1&quot;); let p1 = this.drawImg(ctx,this.tabSrc,tabInitX,tabInitY,tabPicWidth,tabPicHeight); //海报商品图片绘制参数 let goodPicWidth = 400/375 * this.viewWidth * 0.6; let goodPicHeight = 400/375 * this.viewWidth * 0.6; let goodInitX = (this.viewWidth - goodPicWidth)/2; let goodInitY = tabPicHeight+tabInitY*2; let p2 = this.drawImg(ctx,this.imgSrc,goodInitX,goodInitY,goodPicWidth,goodPicHeight); this.wrapText(ctx,this.goodDesc,this.viewHeight - tabInitY*27, tabInitY,this.viewHeight * 0.35 + tabPicHeight+(tabInitY*4),20,15,&quot;black&quot;); this.wrapText(ctx,`￥$&#123;this.newPrice&#125;`,this.viewHeight - tabInitY*27,tabInitY, this.viewHeight * 0.35 + tabPicHeight+(tabInitY*4)+60,20,18,&quot;black&quot; ); this.wrapText(ctx,`市场价￥$&#123;this.oldPrice&#125;`,this.viewHeight - tabInitY*27,tabInitY*30, this.viewHeight * 0.35 + tabPicHeight+(tabInitY*4)+60,20,13,&quot;darkgrey&quot; ); this.wrapText(ctx,&quot;heathen&quot;,this.viewHeight - tabInitY*27,85, 420,20,14,&quot;black&quot; ); this.wrapText(ctx,&quot;邀请你参与&quot;,this.viewHeight - tabInitY*27,85, 440,20,15,&quot;black&quot; ); this.wrapText(ctx,&quot;长按扫码&quot;,this.viewHeight - tabInitY*27,310, 440,20,12,&quot;darkgrey&quot; ); this.wrapText(ctx,&quot;查看详情&quot;,this.viewHeight - tabInitY*27,310, 420,20,12,&quot;darkgrey&quot; ); let p3 = this.pictureCut(ctx,this.userinfo.avatarUrl); Promise.all([p1,p2,p3]).then(()=&gt;&#123; ctx.drawImage(this.opcCode,240,400,60,60) ctx.draw(false,()=&gt;&#123; uni.canvasToTempFilePath(&#123; canvasId: &#x27;myCanvas&#x27;, success: function(res) &#123; // 在H5平台下，tempFilePath 为 base64 that.poster = res.tempFilePath; &#125; &#125;) &#125;); uni.hideLoading(); this.isShow = !this.isShow; &#125;) &#125;, /** * canvas实现自动换行 * @param &#123;canvas对象&#125; ctx * @param &#123;描述&#125; canText * @param &#123;文本最大宽度,超过就换行&#125; MaxWidth * @param &#123;绘制文本X坐标&#125; startX * @param &#123;绘制文本Y坐标&#125; startY * @param &#123;行高&#125; lineHeight * @param &#123;字体大小&#125; fontSize * @param &#123;字体颜色&#125; fontColor */ wrapText(ctx,canText,MaxWidth,startX,startY,lineHeight,fontSize,fontColor)&#123; if (typeof canText != &#x27;string&#x27; || typeof startX != &#x27;number&#x27; || typeof startY != &#x27;number&#x27;) &#123; return; &#125; ctx.setFillStyle(fontColor);//文字颜色：默认黑色 ctx.setFontSize(fontSize);//设置字体大小，默认10 ctx.setTextAlign(&quot;left&quot;);// 设置位置 ctx.textBaseline = &#x27;middle&#x27;; // 字符分隔为数组 let arrText = canText.split(&#x27;&#x27;); let line = &#x27;&#x27;; for(let n = 0;n &lt; arrText.length; n++)&#123; let containerLine = line + arrText[n]; let containerLimit = ctx.measureText(containerLine); let containerWidth = containerLimit.width; if(containerWidth &gt; MaxWidth &amp;&amp; n &gt; 0)&#123; ctx.fillText(line, startX, startY); line = arrText[n]; startY += lineHeight; &#125; else &#123; line = containerLine; &#125; &#125; ctx.fillText(line, startX, startY); &#125;, /** * canvas绘制背景颜色 * @param &#123;canvas对象&#125; ctx * @param &#123;初始X轴坐标&#125; startX * @param &#123;初始Y轴坐标&#125; startY * @param &#123;绘制矩形X坐标&#125; drawX * @param &#123;绘制矩形Y坐标&#125; drawY * @param &#123;背景颜色&#125; bc */ drawBackgroundColor(ctx,startX,startY,drawX,drawY,bc)&#123; ctx.beginPath() ctx.rect(startX, startY, drawX,drawY); ctx.setFillStyle(bc); ctx.fill(); ctx.closePath(); &#125;, /** * @param &#123;canvas对象&#125; ctx * @param &#123;图片源&#125; img * @param &#123;初始X轴坐标&#125; startX * @param &#123;初始Y轴坐标&#125; startY * @param &#123;绘制矩形X坐标&#125; drawX * @param &#123;绘制矩形Y坐标&#125; drawY */ drawImg(ctx,img,startX,startY,drawX,drawY)&#123; return this.downfile(img).then((value) =&gt; &#123; ctx.drawImage(value,startX,startY,drawX,drawY); &#125;) &#125;, downfile(url)&#123;//下载网络图片的promise对象 return new Promise(function (resolve, reject) &#123; uni.downloadFile(&#123; url:url , success: function (res) &#123; resolve(res.tempFilePath) &#125; &#125;) &#125;) &#125;, pictureCut(ctx,img)&#123; return this.downfile(img).then((value)=&gt;&#123; ctx.save(); ctx.beginPath(); ctx.arc(45, 430, 30, 0, 2 * Math.PI); ctx.clip(); ctx.drawImage(value, 15, 400, 60, 60); ctx.restore(); &#125;) &#125;, getUserInfor()&#123; return new Promise(function (resolve, reject) &#123; uni.getUserProfile(&#123; desc:&#x27;获取你的昵称、头像、地区及性别&#x27;, success: function (infoRes) &#123; resolve(infoRes.userInfo); &#125; &#125;) &#125;) &#125;, saveImg()&#123; uni.saveImageToPhotosAlbum(&#123; filePath:this.poster, success() &#123; console.log(&quot;保存成功&quot;); &#125; &#125;) &#125; &#125;, onShow()&#123; uni.getSystemInfo(&#123; success:res=&gt;&#123; this.viewWidth = res.windowWidth; this.viewHeight = res.windowHeight; &#125; &#125;) &#125; &#125;&lt;/script&gt;&lt;style&gt; .mytest&#123; display: flex; justify-content: center; align-items: center; position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; background: rgba(0,0,0,.8); /* background-color:red; */ &#125; .posterBox&#123; display: flex; flex-direction: column; align-items: center; &#125; .posterImg&#123; width: 337px; height: 433px; border-radius: 20px; &#125; .btn&#123; width: 60%; height: 35px; margin-top: 20px; text-align: center; background-color: #F4F4F4; line-height: 35px; border-radius: 20px; font-size: 14px; &#125;&lt;/style&gt;","categories":[{"name":"小程序","slug":"小程序","permalink":"http://example.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://example.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"uniapp","slug":"uniapp","permalink":"http://example.com/tags/uniapp/"}]},{"title":"Vue组件封装笔记","slug":"关于Vue组件封装","date":"2022-06-06T04:16:12.000Z","updated":"2023-02-14T14:57:45.516Z","comments":true,"path":"2022/06/06/关于Vue组件封装/","link":"","permalink":"http://example.com/2022/06/06/%E5%85%B3%E4%BA%8EVue%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/","excerpt":"","text":"关于Vue组件封装 以下都是Vue2写法 Vue的组件封装都挺相似的，可以分为三个部分： 1、props：父向子传输数据 props是子组件用来接受父组件传过来的数据的 父组件通过子组件标签，:mes&#x3D;”mes”来向子组件发送数据 另：子组件接收父组件的数据，一般是不直接修改传过来的数据。子组件想要修改数据，可以向父组件通信this.$emit(“event”,param)，让父组件来修改数据。这样做是保证了数据的单向流动，便于数据追踪，因为组件多了、项目大了，如果允许数据双向流动的话，排错起来会非常头痛。非要子组件修改数据的话，浏览器控制台上能看到报错，报错如下： 父组件father.vue 123456789101112131415161718192021222324&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;son :mes=&quot;mes&quot;&gt;&lt;/son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import son from &quot;./son.vue&quot;;export default &#123;name:&#x27;father&#x27;,components:&#123; son&#125;, data () &#123; return &#123; mes:&quot;父组件message&quot; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 子组件children.vue 在子组件中声明props，来接收父组件发过来的数组 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=&quot;children&quot;&gt; 子组件 &lt;div&gt;我是父组件传来的值：&#123;&#123;mes&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name:&#x27;children&#x27;,props:&#123; mes:&#123; type:String, default:&quot;我是默认值&quot; &#125;&#125;, data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 关于props存在形式 对象形式or数数组形式 数组形式： 123//数组形式：props:[&#x27;mes&#x27;,&#x27;example&#x27;]//这是props以数组的形式存在。当然不论数组形式还是对象形式，props都可以接手父组件传过来的多个数据 对象形式 12345678910111213141516171819202122232425262728293031//对象形式//对象形式穿过来的数据，在接受时，可以做类型的限制、赋予默认值、是否必传等props: &#123; // 基础类型检测 (`null` 意思是任何类型都可以) propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组/对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: &#x27;hello&#x27; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125; 2、emit：子触发父事件 子组件触发父组件事件，通过this.$emit(‘sonTofather’, data) 父组件father.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;son :mes=&quot;mes&quot; @sonTofather=&quot;sonTofather&quot;&gt;&lt;/son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import son from &quot;./son.vue&quot;;export default &#123;name:&#x27;father&#x27;,components:&#123; son&#125;, data () &#123; return &#123; mes:&quot;父组件message&quot; &#125; &#125;, methods: &#123; sonTofather(message)&#123; console.log(message); &#125; &#125;,&#125;&lt;/script&gt; 子组件children.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div class=&quot;son&quot;&gt; 子组件 &lt;div&gt;我是父组件传来的值：&#123;&#123;mes&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;updataValue&quot;&gt;点击修改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name:&#x27;son&#x27;,props:[&#x27;mes&#x27;,&#x27;example&#x27;], data () &#123; return &#123; &#125; &#125;, methods: &#123; updataValue()&#123; this.$emit(&quot;sonTofather&quot;,&quot;子组件消息&quot;); &#125; &#125;,&#125; 3、slot：插槽 说到插槽就离不开三样，默认插槽、具名插槽、插槽作用域，但是这里就不展开说。 只说插槽应用于封装组件的部分。 插槽的应用，对于组件的封装起到锦上添花的作用，让组件的封装更加的灵活多样。 但是我不想写代码举例了，因为太太麻烦了，懒。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"VUe2","slug":"VUe2","permalink":"http://example.com/tags/VUe2/"}]},{"title":"前端二进制相关","slug":"前端二进制相关","date":"2022-05-06T04:16:12.000Z","updated":"2023-02-14T16:08:11.311Z","comments":true,"path":"2022/05/06/前端二进制相关/","link":"","permalink":"http://example.com/2022/05/06/%E5%89%8D%E7%AB%AF%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%85%B3/","excerpt":"","text":"前端二进制相关 前端二进制相关的有Blob、File、Base64、FileReader、ArrayBuffer等 ArrayBuffer 123ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图进行操作。// 创建一个长度为 16 的 buffer 它会分配一个 16 字节（byte）的连续内存空间，并用 0 进行预填充。const buffer1 = new ArrayBuffer(16); Blob 1234567Blob 对象表示一个不可变、原始数据的类文件对象。// 构造函数const blob = new Blob(array, options);array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的数组，DOMStrings会被编码为UTF-8。options 是一个可选，它可能会指定如下两个属性：type，默认值为 &quot;&quot;，内容的MIME类型。endings，默认值为&quot;transparent&quot;，用于指定包含行结束符\\n的字符串如何被写入。 它是以下两个值中的一个： &quot;native&quot;，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 &quot;transparent&quot;，代表会保持blob中保存的结束符不变 Blob url 生成blob url使用的方法是URL.createObjectURL(file/blob)。清除方式只有页面unload()事件或者使用URL.revokeObjectURL(objectURL)手动清除 。 123456789101112131415export const downloadFile = async (params, fileName) =&gt; &#123; // 我们使用axios设置接口返回类型 responseType: &quot;blob&quot;, 所以这里从后端返回的是blob。 const results = await download(params); const a = document.createElement(&quot;a&quot;); a.download = fileName + &quot;.xlsx&quot;; // 生成blob url。这里可以使用Blob对象或者File对象 a.href = window.URL.createObjectURL(results); a.style.display = &quot;none&quot;; document.body.appendChild(a); a.click(); // 释放内存 window.URL.revokeObjectURL(a.href); document.body.removeChild(a);&#125;; file File 描述文件信息的一个对象，可以让 JavaScript 访问文件信息。File 继承于 Blob。 Base64 123Base64是一种编码格式，在前端经常会碰到，格式是 data:[&lt;mediatype&gt;][;base64],&lt;data&gt; 。除了使用工具进行Base64编码外，js还内置了两个方法能进行字符串的Base64的编码和解码。 123456789const str1 = &quot;hello randy&quot;;// 编码const b1 = window.btoa(str1);console.log(b1); // aGVsbG8gcmFuZHk=// 解码const str2 = window.atob(b1);console.log(str2); // hello randy 作用： 可以将二进制数据（比如图片）转化为可打印字符，方便传输数据。 对数据进行简单的加密，肉眼是安全的。 如果是在html或者css处理图片，可以减少http请求。 缺点： 内容编码后体积变大， 至少大1&#x2F;3。因为是三字节变成四个字节，当只有一个字节的时候，也至少会变成三个字节。 编码和解码需要额外工作量。 FileReader FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容. 属性： FileReader.error 一个DOMException，表示在读取文件时发生的错误 。 FileReader.result 返回文件的内容。只有在读取操作完成后，此属性才有效，返回的数据的格式取决于是使用哪种读取方法来执行读取操作的。 FileReader.readyState 表示FileReader状态的数字。0 还没有加载任何数据。1 数据正在被加载。2 已完成全部的读取请求。 方法: 方法名 描述 FileReader.abort() 中止读取操作。在返回时，readyState 属性为 DONE。 FileReader.readAsArrayBuffer() 将读取的内容转成ArrayBuffer。 FileReader.readAsBinaryString() 将读取的内容转成二进制数据。 FileReader.readAsDataURL() 将读取的内容转成并将其编码为 base64 的 data url。 格式是 data:[&lt;mediatype&gt;][;base64],&lt;data&gt; FileReader.readAsText() 将数据读取为给定编码（默认为 utf-8 编码）的文本字符串。 事件： 事件 描述 FileReader.onabort 处理 abort 事件。该事件在读取操作被中断时触发。 FileReader.onerror 处理 error 事件。该事件在读取操作发生错误时触发。 FileReader.onload 处理 load 事件。该事件在读取操作完成时触发。 FileReader.onloadstart 处理 loadstart 事件。该事件在读取操作开始时触发。 FileReader.onloadend 处理 loadend 事件。该事件在读取操作结束时（要么成功，要么失败）触发。 FileReader.onprogress 处理 progress 事件。该事件在读取Blob时触发。 example： 123456789101112const blob3 = new Blob([&quot;hello&quot;, &quot;randy&quot;], &#123; type: &quot;text/plain&quot; &#125;);const fileReader = new FileReader();fileReader.readAsDataURL(blob3);fileReader.onload = () =&gt; &#123; console.log(fileReader); // 通过fileReader获取结果 // fileReader.result 是结果（如果成功） // fileReader.error 是 error（如果失败）。&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"webpack相关","slug":"webpack","date":"2022-04-06T04:16:12.000Z","updated":"2023-02-14T14:54:17.078Z","comments":true,"path":"2022/04/06/webpack/","link":"","permalink":"http://example.com/2022/04/06/webpack/","excerpt":"","text":"webpack学习笔记 基本属性entry（入口） 指示 Webpack 从哪个文件开始打包 output（输出） 指示 Webpack 打包完的文件输出到哪里去，如何命名等 loader（加载器） webpack 本身只能处理 js、json 等资源，其他资源需要借助 loader，Webpack 才能解析 plugins（插件） 扩展 Webpack 的功能 mode（模式） 主要由两种模式： 开发模式：development 生产模式：production 12345678910111213141516171819202122232425// Node.js的核心模块，专门用来处理文件路径const path = require(&quot;path&quot;);module.exports = &#123; // 入口 // 相对路径和绝对路径都行 entry: &quot;./src/main.js&quot;, // 输出 output: &#123; // path: 文件输出目录，必须是绝对路径 // path.resolve()方法返回一个绝对路径 // __dirname 当前文件的文件夹绝对路径 path: path.resolve(__dirname, &quot;dist&quot;), // filename: 输出文件名 filename: &quot;main.js&quot;, &#125;, // 加载器 module: &#123; rules: [], &#125;, // 插件 plugins: [], // 模式 mode: &quot;development&quot;, // 开发模式&#125;; 样式资源处理webpack只能识别js文件，css&#x2F;sass&#x2F;less样式资源识别不了处理不了，因此如要借助loader加载器来处理样式资源问题 1.css资源处理安装 1npm i css-loader style-loader -D //-D表示开发依赖 两个loader介绍 css-loader：负责将 Css 文件编译成 Webpack 能识别的模块 style-loader：会动态创建一个 Style 标签，里面放置 Webpack 中 Css 模块内容 此时样式就会以 Style 标签的形式在页面上生效 配置 123456789101112131415161718192021const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;main.js&quot;, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, &lt;---------------这里 // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &lt;---------------这里 &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 再然后需要将外部样式资源引入main.js文件中，webpack才能够处理，不引入样式资源文件的话，就没有相关的样式依赖，webpack就不会去处理了 src&#x2F;main.js 1234567import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;// 引入 Css 资源，Webpack才会对其打包import &quot;./css/index.css&quot;;&lt;---------------这里console.log(count(2, 1));console.log(sum(1, 2, 3, 4)); 2.处理sass资源安装 1npm i sass-loader sass -D 两个loader介绍 sass-loader：负责将 Sass 文件编译成 css 文件 sass：sass-loader 依赖 sass 进行编译 此时样式就会以 Style 标签的形式在页面上生效 配置 1234567891011121314151617181920212223242526272829const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;main.js&quot;, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, &lt;---------------这里 use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &lt;---------------这里 &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; src&#x2F;main.js 12345678910import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;// 引入资源，Webpack才会对其打包import &quot;./css/index.css&quot;;import &quot;./less/index.less&quot;;import &quot;./sass/index.sass&quot;;import &quot;./sass/index.scss&quot;;console.log(count(2, 1));console.log(sum(1, 2, 3, 4)); 处理图片资源过去在 Webpack4 时，我们处理图片资源通过 file-loader 和 url-loader 进行处理 现在 Webpack5 已经将两个 Loader 功能内置到 Webpack 里了，我们只需要简单配置即可处理图片资源 配置12345678910111213141516171819202122232425262728293031323334353637const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;main.js&quot;, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/,&lt;---------------这里 type: &quot;asset&quot;, &lt;---------------这里 &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; src&#x2F;less&#x2F;index.less 123456.box2 &#123; width: 100px; height: 100px; background-image: url(&quot;../images/1.jpeg&quot;);//file-loder，url-loader 处理这个路径问题 background-size: cover;&#125; 对图片资源进行优化处理将小于某个大小的图片转化成 data URI 形式（Base64 格式 123456789101112131415161718192021222324252627282930313233343536373839404142const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;main.js&quot;, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024 // 小于10kb的图片会被base64处理 &lt;---------------这里 &#125; &#125; &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 优点：减少请求数量 缺点：体积变得更大 此时输出的图片文件就只有两张，有一张图片以 data URI 形式内置到 js 中了 （注意：需要将上次打包生成的文件清空，再重新打包才有效果） 修改输出资源名称和路径配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 &lt;---------------这里 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; &lt;---------------这里 // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 自动清空上次打包资源配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, clean: true, // 自动将上次打包目录资源清空 &lt;---------------这里 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 40 * 1024, // 小于40kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 处理字体图标资源下载文字图标文件阿里巴巴矢量库 src&#x2F;fonts&#x2F;iconfont.ttf src&#x2F;fonts&#x2F;iconfont.woff src&#x2F;fonts&#x2F;iconfont.woff2 src&#x2F;css&#x2F;iconfont.css 注意字体文件路径需要修改 src&#x2F;main.js 引入12345678910111213import &#123; add &#125; from &quot;./math&quot;;import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;// 引入资源，Webpack才会对其打包import &quot;./css/iconfont.css&quot;;import &quot;./css/index.css&quot;;import &quot;./less/index.less&quot;;import &quot;./sass/index.sass&quot;;import &quot;./sass/index.scss&quot;;import &quot;./styl/index.styl&quot;;console.log(count(2, 1));console.log(sum(1, 2, 3, 4)); public&#x2F;index.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;webpack5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Webpack5&lt;/h1&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; &lt;!-- 使用字体图标 --&gt; &lt;i class=&quot;iconfont icon-arrow-down&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-ashbin&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-browse&quot;&gt;&lt;/i&gt; &lt;script src=&quot;../dist/static/js/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; &lt;---------------这里 test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &lt;---------------这里 ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; type: &quot;asset/resource&quot;和type: &quot;asset&quot;的区别： type: &quot;asset/resource&quot; 相当于file-loader, 将文件转化成 Webpack 能识别的资源，其他不做处理 type: &quot;asset&quot; 相当于url-loader, 将文件转化成 Webpack 能识别的资源，同时小于某个大小的资源会处理成 data URI 形式 处理其他资源开发中可能还存在一些其他资源，如音视频等，我们也一起处理了 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?|map4|map3|avi)$/, &lt;-----------------这里 type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 就是在处理字体图标资源基础上增加其他文件类型，统一处理即可 处理js资源有人可能会问，js 资源 Webpack 不能已经处理了吗，为什么我们还要处理呢？ 原因是 Webpack 对 js 处理是有限的，只能编译 js 中 ES 模块化语法，不能编译其他语法，导致 js 不能在 IE 等浏览器运行，所以我们希望做一些兼容性处理。 其次开发中，团队对代码格式是有严格要求的，我们不能由肉眼去检测代码格式，需要使用专业的工具来检测。 针对 js 兼容性处理，我们使用 Babel 来完成 针对代码格式，我们使用 Eslint 来完成 我们先完成 Eslint，检测代码格式无误后，在由 Babel 做代码兼容性处理 Eslint可组装的 JavaScript 和 JSX 检查工具。 这句话意思就是：它是用来检测 js 和 jsx 语法的工具，可以配置各项功能 我们使用 Eslint，关键是写 Eslint 配置文件，里面写上各种 rules 规则，将来运行 Eslint 时就会以写的规则对代码进行检查 #1. 配置文件配置文件由很多种写法： &#96;&#96;&#96;.eslintrc.*1234567891011121314151617181920212223242526272829 ：新建文件，位于项目根目录 - `.eslintrc` - `.eslintrc.js` - `.eslintrc.json` - 区别在于配置格式不一样- `package.json` 中 `eslintConfig`：不需要创建文件，在原有文件基础上写ESLint 会查找和自动读取它们，所以以上配置文件只需要存在一个即可### 2. 具体配置我们以 `.eslintrc.js` 配置文件为例：```javascriptmodule.exports = &#123; // 解析选项 parserOptions: &#123;&#125;, // 具体检查规则 rules: &#123;&#125;, // 继承其他规则 extends: [], // ... // 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring&#125;; parserOptions 解析选项 1234567parserOptions: &#123; ecmaVersion: 6, // ES 语法版本 sourceType: &quot;module&quot;, // ES 模块化 ecmaFeatures: &#123; // ES 其他特性 jsx: true // 如果是 React 项目，就需要开启 jsx 语法 &#125;&#125; rules 具体规则 &quot;off&quot; 或 0 - 关闭规则 &quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出) &quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出) 123456789101112rules: &#123; semi: &quot;error&quot;, // 禁止使用分号 &#x27;array-callback-return&#x27;: &#x27;warn&#x27;, // 强制数组方法的回调函数中有 return 语句，否则警告 &#x27;default-case&#x27;: [ &#x27;warn&#x27;, // 要求 switch 语句中有 default 分支，否则警告 &#123; commentPattern: &#x27;^no default$&#x27; &#125; // 允许在最后注释 no default, 就不会有警告了 ], eqeqeq: [ &#x27;warn&#x27;, // 强制使用 === 和 !==，否则警告 &#x27;smart&#x27; // https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告 ],&#125; 更多规则详见：规则文档open in new window extends 继承 开发中一点点写 rules 规则太费劲了，所以有更好的办法，继承现有的规则。 现有以下较为有名的规则： Eslint 官方的规则open in new window：eslint:recommended Vue Cli 官方的规则open in new window：plugin:vue/essential React Cli 官方的规则open in new window：react-app 123456789// 例如在React项目中，我们可以这样写配置module.exports = &#123; extends: [&quot;react-app&quot;], rules: &#123; // 我们的规则会覆盖掉react-app的规则 // 所以想要修改规则直接改就是了 eqeqeq: [&quot;warn&quot;, &quot;smart&quot;], &#125;,&#125;; #3. 在 Webpack 中使用 下载包 1npm i eslint-webpack-plugin eslint -D 定义 Eslint 配置文件 .eslintrc.js 123456789101112131415module.exports = &#123; // 继承 Eslint 规则 extends: [&quot;eslint:recommended&quot;], env: &#123; node: true, // 启用node中全局变量 browser: true, // 启用浏览器中全局变量 &#125;, parserOptions: &#123; ecmaVersion: 6, sourceType: &quot;module&quot;, &#125;, rules: &#123; &quot;no-var&quot;: 2, // 不能使用 var 定义变量 &#125;,&#125;; 修改 js 文件代码 main.js 1234567891011121314import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;// 引入资源，Webpack才会对其打包import &quot;./css/iconfont.css&quot;;import &quot;./css/index.css&quot;;import &quot;./less/index.less&quot;;import &quot;./sass/index.sass&quot;;import &quot;./sass/index.scss&quot;;import &quot;./styl/index.styl&quot;;var result1 = count(2, 1);console.log(result1);var result2 = sum(1, 2, 3, 4);console.log(result2); 配置 webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;); &lt;-----------------这里//plugin使用一般是 下载、引入、使用module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;src&quot;), &#125;), ], mode: &quot;development&quot;,&#125;; BabelJavaScript 编译器。 主要用于将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中 #1. 配置文件配置文件由很多种写法： babel.config.* 12345678 ：新建文件，位于项目根目录 - `babel.config.js` - `babel.config.json`- ``` .babelrc.* ：新建文件，位于项目根目录 - `.babelrc` - `.babelrc.js` - `.babelrc.json` package.json 中 babel：不需要创建文件，在原有文件基础上写 Babel 会查找和自动读取它们，所以以上配置文件只需要存在一个即可 #2. 具体配置我们以 babel.config.js 配置文件为例： 1234module.exports = &#123; // 预设 presets: [],&#125;; presets 预设 简单理解：就是一组 Babel 插件, 扩展 Babel 功能 @babel/preset-env: 一个智能预设，允许您使用最新的 JavaScript。 @babel/preset-react：一个用来编译 React jsx 语法的预设 @babel/preset-typescript：一个用来编译 TypeScript 语法的预设 #3. 在 Webpack 中使用 下载包 1npm i babel-loader @babel/core @babel/preset-env -D 定义 Babel 配置文件 babel.config.js 123module.exports = &#123; presets: [&quot;@babel/preset-env&quot;],&#125;; 修改 js 文件代码 main.js 1234567891011121314import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;// 引入资源，Webpack才会对其打包import &quot;./css/iconfont.css&quot;;import &quot;./css/index.css&quot;;import &quot;./less/index.less&quot;;import &quot;./sass/index.sass&quot;;import &quot;./sass/index.scss&quot;;import &quot;./styl/index.styl&quot;;const result1 = count(2, 1);console.log(result1);const result2 = sum(1, 2, 3, 4);console.log(result2); 配置 webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; &lt;-----------------这里 test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;src&quot;), &#125;), ], mode: &quot;development&quot;,&#125;; 处理 Html 资源#1. 下载包1npm i html-webpack-plugin -D #2. 配置 webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);&lt;-----------------这里module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;src&quot;), &#125;), new HtmlWebpackPlugin(&#123; &lt;-----------------这里 // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;public/index.html&quot;), &#125;), ], mode: &quot;development&quot;,&#125;; #3. 修改 index.html去掉引入的 js 文件，因为 HtmlWebpackPlugin 会自动引入 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;webpack5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Webpack5&lt;/h1&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; &lt;i class=&quot;iconfont icon-arrow-down&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-ashbin&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-browse&quot;&gt;&lt;/i&gt; &lt;/body&gt;&lt;/html&gt; 开发服务器&amp;自动化每次写完代码都需要手动输入指令才能编译代码，太麻烦了，我们希望一切自动化 #1. 下载包1npm i webpack-dev-server -D #2. 配置 webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;public/index.html&quot;), &#125;), ], // 开发服务器 devServer: &#123; &lt;-----------------这里 host: &quot;localhost&quot;, // 启动服务器域名 port: &quot;3000&quot;, // 启动服务器端口号 open: true, // 是否自动打开浏览器 &#125;, mode: &quot;development&quot;,&#125;; 生产模式介绍生产模式是开发完成代码后，我们需要得到代码将来部署上线。 这个模式下我们主要对代码进行优化，让其运行性能更好。 优化主要从两个角度出发: 优化代码运行性能 优化代码打包速度 #生产模式准备我们分别准备两个配置文件来放不同的配置 #1. 文件目录123456789101112├── webpack-test (项目根目录) ├── config (Webpack配置文件目录) │ ├── webpack.dev.js(开发模式配置文件) │ └── webpack.prod.js(生产模式配置文件) ├── node_modules (下载包存放目录) ├── src (项目源码目录，除了html其他都在src里面) │ └── 略 ├── public (项目html文件) │ └── index.html ├── .eslintrc.js(Eslint配置文件) ├── babel.config.js(Babel配置文件) └── package.json (包的依赖管理配置文件) #2. 修改 webpack.dev.js因为文件目录变了，所以所有绝对路径需要回退一层目录才能找到对应的文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: undefined, // 开发模式没有输出，不需要指定输出目录 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 // clean: true, // 开发模式没有输出，不需要清空输出结果 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), ], // 其他省略 devServer: &#123; host: &quot;localhost&quot;, // 启动服务器域名 port: &quot;3000&quot;, // 启动服务器端口号 open: true, // 是否自动打开浏览器 &#125;, mode: &quot;development&quot;,&#125;; 运行开发模式的指令： 1npx webpack serve --config ./config/webpack.dev.js #3. 修改 webpack.prod.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;)/ 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; 运行生产模式的指令： 1npx webpack --config ./config/webpack.prod.js #4. 配置运行指令为了方便运行不同模式的指令，我们将指令定义在 package.json 中 scripts 里面 123456789// package.json&#123; // 其他省略 &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;npm run dev&quot;, &quot;dev&quot;: &quot;npx webpack serve --config ./config/webpack.dev.js&quot;, &quot;build&quot;: &quot;npx webpack --config ./config/webpack.prod.js&quot; &#125;&#125; 以后启动指令： 开发模式：npm start 或 npm run dev 生产模式：npm run build Css 处理#提取 Css 成单独文件Css 文件目前被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式 这样对于网站来说，会出现闪屏现象，用户体验不好 我们应该是单独的 Css 文件，通过 link 标签加载性能才好 #1. 下载包1npm i mini-css-extract-plugin -D #2. 配置 webpack.prod.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), ], // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; #3. 运行指令1npm run build #Css 兼容性处理#1. 下载包1npm i postcss-loader postcss postcss-preset-env -D #2. 配置 webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, ], &#125;, &#123; test: /\\.less$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, &quot;less-loader&quot;, ], &#125;, &#123; test: /\\.s[ac]ss$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, &quot;sass-loader&quot;, ], &#125;, &#123; test: /\\.styl$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, &quot;stylus-loader&quot;, ], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), ], // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; 60616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141 #3. 控制兼容性我们可以在 package.json 文件中添加 browserslist 来控制样式的兼容性做到什么程度。 1234&#123; // 其他省略 &quot;browserslist&quot;: [&quot;ie &gt;= 8&quot;]&#125; 想要知道更多的 browserslist 配置，查看browserslist 文档open in new window 以上为了测试兼容性所以设置兼容浏览器 ie8 以上。 实际开发中我们一般不考虑旧版本浏览器了，所以我们可以这样设置： 1234&#123; // 其他省略 &quot;browserslist&quot;: [&quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;not dead&quot;]&#125; #4. 合并配置 webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);// 获取处理样式的Loadersconst getStyleLoaders = (preProcessor) =&gt; &#123; return [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, preProcessor, ].filter(Boolean);&#125;;module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: getStyleLoaders(), &#125;, &#123; test: /\\.less$/, use: getStyleLoaders(&quot;less-loader&quot;), &#125;, &#123; test: /\\.s[ac]ss$/, use: getStyleLoaders(&quot;sass-loader&quot;), &#125;, &#123; test: /\\.styl$/, use: getStyleLoaders(&quot;stylus-loader&quot;), &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), ], // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; #5. 运行指令1npm run build #Css 压缩#1. 下载包1npm i css-minimizer-webpack-plugin -D #2. 配置 webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);// 获取处理样式的Loadersconst getStyleLoaders = (preProcessor) =&gt; &#123; return [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, preProcessor, ].filter(Boolean);&#125;;module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: getStyleLoaders(), &#125;, &#123; test: /\\.less$/, use: getStyleLoaders(&quot;less-loader&quot;), &#125;, &#123; test: /\\.s[ac]ss$/, use: getStyleLoaders(&quot;sass-loader&quot;), &#125;, &#123; test: /\\.styl$/, use: getStyleLoaders(&quot;stylus-loader&quot;), &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), // css压缩 new CssMinimizerPlugin(), ], // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; 注意1.sasss-loader安装sass-loader需要安装另外两个loader才能够使用sass-loader，css-loader style-loader sass-loader是将sass语法转化为css、但是不单独生成一个css文件 css-loader是让webpack识别css文件，将css以commonjs方式整合到js文件中 ， style是将css插入到html文档中，即创建个style标签，将样式放进去。 2.eslint-loader&#x2F;&#x2F;eslint-loader不再推荐 都是用eslint plugin了 对js基本语法错误&#x2F;隐患，进行提前检查 npm install eslint-loader eslint –save-dev 123456789101112module：&#123;rules:[&#123;test:/\\.js$/, //只检测js文件exclude:/node_modules/, //排除node_modules文件夹enforce:&#x27;pre&#x27;, //提前加载使用use:&#123; //使用eslint-loader解析loader:&#x27;eslint-loader&#x27;&#125;&#125;]&#125; eslint配置的规则，需要到package.json中配置才行 &#x2F;&#x2F;package.json是包的说明文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374方式一:配置eslint-loader 1、下载 cnpm install -D eslint-config-airbnb-base eslint eslint-plugin-import eslint-loader 使用airbnb-base库来进行代码检查 手动配置检查: 去官网demo/演示中自行配置然后下载.eslintrc.json文件,其中配置包含选择的rules 2、配置 module:&#123; rules:[ &#123; test: /\\.js$/, exclude:/node_modules/, 不检查node_modules loader: &#x27;eslint-loader&#x27;, enforce:&#x27;pre&#x27;, 优先执行该loader,避免其他loader对js文件处理后(如兼容性处理)报错 options: &#123; fix:true 检查出错误后自动修复 &#125; &#125; ] &#125;, 添加eslint配置: 方式一: 修改package.json,添加eslintConfig,与devDependencies同级设置 &quot;eslintConfig&quot;: &#123; &quot;extends&quot;: &quot;airbnb-base&quot;, 使用airbnb-base库进行代码检查 &quot;env&quot;:&#123; &quot;browser&quot;:true 添加浏览器全局变量 &#125; &#125; 方式二: 创建.eslintrc.*文件,可以是js、json或yaml,js文件需要module.exports导出 (1)下载: cnpm install -D babel-eslint (2)配置: module.exports = &#123; &quot;parser&quot;: &quot;babel-eslint&quot;, 可以使用babel-eslint来解析ESLint本身还不支持的类型(流)或实验性特性,否则使用默认即可,需要先下载 &quot;parserOptions&quot;: &#123; &quot;sourceType&quot;: &quot;module&quot;, 支持es6+语法 &quot;allowImportExportEverywhere&quot;: false, 支持import和export在任何地方 &quot;codeFrame&quot;: true &#125;, &quot;env&quot;: &#123; 支持的环境 &quot;browser&quot;: true, &quot;node&quot;:true &#125;, &quot;extends&quot;:[&quot;airbnb-base&quot;], 使用airbnb-base库的规范,如果下载的是eslint-config-airbnb就使用airbnb &quot;rules&quot;: &#123; 修改或添加验证规则,具体规则查看eslint官网 &#125; &#125; 3、避开代码检查 在需要避开检查的代码上一行添加如下注释 //eslint-disable-next-line方式二:通过命令行启动eslint (1)下载 cnpm install -D eslint-config-airbnb-base eslint eslint-plugin-import eslint-loader cnpm install -g eslint-cli (2)配置.eslintrc.js如上方所示 (3)运行 eslint 文件目录/文件路径 --fix --fix 自动修复 例子: eslint --fix --ext .后缀1,.后缀2 目录路径 目录路径2 具体命令行规则:http://eslint.cn/docs/user-guide/command-line-interface 3.js语法转换概述：将浏览器不能识别的新语法转换为原来识别的旧语法，做浏览器兼容处理。 为什么还要js转换，因为一些jsx、ts、es6+等比较新的语法不能被一些较低版本的浏览器识别，因此需要向下兼容 babel-loader 只能转换部分低级语法，例如let const &#x2F;解构赋值等 js兼容处理 polyfill 可以将新的es6+语法向下兼容，例如promise等 @babel&#x2F;polyfill 12345678910&#123;test:/\\.js$/,exclude:/node_modules/,use:&#123;loader:&#x27;babel-loader&#x27;,options:&#123;presets:[&#x27;@babel/preset-env&#x27;]&#125;&#125;&#125; polyfill缺点： polyfill这个loader，它不管编码人员用了哪些新语法，全部的新语法都转换。这样导致js文件会变大，我们应该让polyfill按需加载，即我们用到的新语法才转换。 解决办法：按需加载。 按需加载需要用到core-js 安装core.js npm install core.js 配置loader 123456789101112131415161718192021&#123;test:/\\.js$/,use:&#123;loader:&#x27;babel-loader&#x27;,options:&#123;presets:[[&#x27;@babel/preset-env&#x27;,&#123;useBuiltIns:&#x27;usage&#x27;,//按需引入需要使用polyfillcorejs:&#123; version:3 &#125;,//解决warn 指定corejs版本targets:&#123;//指定兼容性处理那些浏览器&quot;chrome&quot;:&quot;58&quot;,&quot;ie&quot;:&quot;9&quot;&#125;&#125;]]cacheDirectory:true,//开启缓存&#125;&#125;&#125; 打包样式文件中的图片资源图片文件webpack不能解析，需要借助loader来解析。 安装loader 1npm install file-loader url-loader --save-dev url-loader是对象file-loader的上层封装，使用时需要配合file-loader使用 1234567891011&#123; test: /\\.(png|jpg|jpeg|gif)$/, //匹配图片文件 use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 8192 //图片大小，超过8192 &#125; &#125; ]&#125; file-loader配置 12345678910111213141516171819module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: &#x27;file-loader&#x27;, options: &#123; publicPath:&#x27;../dist/images&#x27;,//决定图片的url路径，就会打包后图片的路径会对不上，例如打包后图片路径为/src/img/xxx.jpg，开发时这路径是对的，但是打包后没有src这个路径了，因此需要改变打包后的图片路径名称 outputPath:&#x27;images&#x27;,//决定文件本地输出路径，指的是将上面匹配的图片打包的到指定文件中 name: &#x27;static/img/[name].[contenthash].[ext]&#x27; //&#x27;[hash:8].[ext]&#x27;修改文件名称，hash值取前8位作为文件名称[ext]表示文件后缀名，[ext]代表图片原来的格式，例如jsp，那么打包后也是jpg &#125;, &#125;, ], &#125;, ], &#125;,&#125;; file-loader跟url-loader功能差不多，但是使用url-loader前提需要file-loader作为支持。 url-loader多了个功能，就是可以设置多大的图片来干嘛，例如大于8kb的图片就不转base64，小于的就转，因为一般来说，小于8kb的图片转base64体积更小些 12345678910111213141516171819module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: &#x27;url -loader&#x27;, options: &#123; publicPath:&#x27;../dist/images&#x27;,//决定图片的url路径，就会打包后图片的路径会对不上，例如打包后图片路径为/src/img/xxx.jpg，开发时这路径是对的，但是打包后没有src这个路径了，因此需要改变打包后的图片路径名称 outputPath:&#x27;images&#x27;,//决定文件本地输出路径，指的是将上面匹配的图片打包的到指定文件中 name: &#x27;static/img/[name].[contenthash].[ext]&#x27; //&#x27;[hash:8].[ext]&#x27;修改文件名称，hash值取前8位作为文件名称[ext]表示文件后缀名，[ext]代表图片原来的格式，例如jsp，那么打包后也是jpg &#125;, &#125;, ], &#125;, ], &#125;,&#125;; 打包html文件如果不打包html文件的话，那么就要手动的将html文件放到打包文件中了，放到打包文件中还需要手动引入js html文件webpack不能解析，需要借助插件编译解析 不要在html中引入任何css和js文件 安装 npm install html-webpack-plugin –save-dev 配置 123456var HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;) new HtmlWebpackPlugin(&#123; filename: &#x27;index.html&#x27;, template: &#x27;index.html&#x27;, //本地自定义模板 inject: true|body &#125;) HtmlWebpackPlugin 的配置非常丰富，不过常用的就几个。 1234567plugins: [ new HtmlWebpackPlugin(&#123; title: &#x27;前端西瓜哥的博客&#x27;, favicon: &#x27;static/favicon.ico&#x27;, &#125;),],复制代码 titile：设置网页标题； filename：生成 html 文件名，默认值为 index/html； template：使用自己的模板，这里填这个模板的路径，使用了之后一些配置项就无效了，比如 title； favicon：指定网站图标路径，除了会在 html 上填充 favicon 相关内容，还会将该文件拷贝到打包文件夹下，非常好用； minify：是否压缩 html 文件。不设置时，如果 webpack 的 mode 为 production，就会压缩 html，移除多余的空格和注释之类的 12345plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27;//以当前文件为模板创建新的hmtl &#125;),], 使用html插件引发的问题html中的图标引入路径等路径问题，用html插件打包后，img等标签上的路径会出问题，这是因为打包html路径没做修改，用了源代码上的路径，因此路径出现问题。即通过url-loader时，配置了这个name: ‘static&#x2F;img&#x2F;[name].[contenthash].[ext]’，修改了图片名字， html中图片url-loader没法处理，它只能处理js中引入的图片&#x2F;样式中的图片，不能处理html中img标签，需要引入其他html-loader处理 问题 在html中添加了img标签，打包是图片路径对不上 解决，使用html-loader，是用来处理html中标签问题的 1npm install html-loader --save-dev 123456&#123;test:/\\.html$/,use:&#123; loader:&#x27;html-loader&#x27; &#125;&#125; 解决其他打包资源其他资源webpack也不能解析，需要接触loader来解析，例如图标 通过file-loader来处理其他资源 123456789&#123; test: /\\.(png|jpg|gif|svg|eot|ttf|woff|woff2)$/, // loader: &#x27;file-loader?name=images/[name].[ext]&#x27;, loader: &#x27;file-loader&#x27;, options: &#123; outputPaht:&#x27;media&#x27;, name:&#x27;imgs/[name].[ext]&#x27; &#125;&#125;, 自动编译打包运行npm install webpack-dev-server –save-dev 12345devServer: &#123; open:true,自动打开浏览器 compress:true,启动gzip压缩 port:3000,端口号 &#125; 问题 在本地自动服务器运行编写的代码时，也会出现图片文件找不到的问题，这是因为在配置url-loader时，指定的publicPath为’..&#x2F;dist&#x2F;images’,因此打包到本地服务器运行时，图片路径就对不上了，改成publicPath:’images&#x2F;‘即可 热更新热更新也就是热模替换 热更新指的是当修改一部分代码时，例如只修改了样式问题，那么热更新这技术就会只更新修改了css那一块的东西，其他不会修改，减少消耗，而不是修改一点东西全部刷新 123456devServer: &#123; open:true,自动打开浏览器 compress:true,启动gzip压缩 port:3000,//端口号 hot:true//开启热更新 &#125; 这样引发的问题就是 例如说 html有一个input标签了，我再添加一个的时候，热更新没有更新出来新添加的input，这是因为entry入口只填了一个入口文件，即main.js，加多一个入口便可以解决了 1entry:[&#x27;/src/main.js&#x27;,&#x27;public/index.html&#x27;], devtool一种将压缩&#x2F;编译文件中的代码映射回源文件中原始位置的技术，就是说经过压缩之后代码报错，是很那找出来代码具体在那个文件哪行出错的，这个devtool就是用来告诉我们代码出错的具体位置。 12开发环境：cheap-module-eval-source-map生产环境:cheap-module-source-map cheap只保留行，编译速度快， eval webpack生成的代码（每个模块彼此分开，并使用模块名称进行注释），编译速度快 inline以base64方式将source-map嵌入到代码中，缺点造成编译后代码体积大 devtool的配置也是在webpack.config中配的 准备生产环境 创建config文件夹，将webpack.config.js复制两份 一份用于开发的配置 一份用于生产的配置 12./config/webpack.dev.js ./config/webpack.prod.js p12 1min 清除打包文件目录每次打包生成文件，都要手动删除，引入插件帮我们自动删除上一次的文件 安装 1npm install clean-webpack-plugin --save-dev 提取css单出成文件1npm install mini-css-extract-plugin --save-dev css兼容处理npm install postcss-loader autoprefixer –save-dev porstcss-loader 需要借助autoprefixer才能够干活 压缩css压缩html压缩jswebpack3需要借助uglyfly-js来压缩js，但是webpack4只需要将mode:’production’ &#x2F;&#x2F;将打包模式为生产模式，webpack4自动会压缩js 总结常用的loader sass-loader css-loader style-loader file-loader url-loader postcss-loader + autofixer babel-loader 常用plugin eslint-webpack-plugin html-webpack-plugin mini-css-extract-plugin clean-webpack-plugin 123456789101112131415常用loader 1.sass-loader sass-loader sass转css sass-loader需要css-loader和style-loader来作为基础，才能够有用 配置需要注意的是：需要按循序，从下到上，或者从右到左。sass-css-style &#123; test: /\\.scss$/, use: [&#123; loader: &quot;style-loader&quot; // 将 JS 字符串生成为 style 节点 &#125;, &#123; loader: &quot;css-loader&quot; // 将 CSS 转化成 CommonJS 模块 &#125;, &#123; loader: &quot;sass-loader&quot; // 将 Sass 编译成 CSS &#125;] &#125; ​ ​ ​ 2.css-loader​ 将css样式以commonjs的形式映射到commonjs当中，并且将其导出​ ​ 3.style-loader​ 将我们的css样式通过style标签的形式添加到html文件中，让样式生效​ ​ 4.file-loader​ 让webpack解析一些文件类型的资源，例如png、jgp等​ {​ test: &#x2F;.(png|jpe?g|gif)$&#x2F;i,​ loader: ‘file-loader’,​ options: {​ name: ‘[name][hash:8].[ext]’,​ publicPath: “https://www.tencent.com“,​ },​ },​ 打包源码时，图片路径可能会出现问题，例如..&#x2F;src&#x2F;images&#x2F;xx.jpg等​ publicPath就是用来修改路径的，也可以在output那设置​ ​ 5.url-loader​ url-loader跟file-loader功能差不多，就是比file多了个对文件大小限制以及一些处理。​ 注意：url-loader的使用前提是要安装了file-loader,url-loader需要file-loader的支撑。​ ​ module.exports &#x3D; {​ module: {​ rules: [​ {​ test: &#x2F;.(png|jpg|jpeg)$&#x2F;,​ use: [​ {​ loader: ‘url-loader’,​ options: {​ name: ‘[name][hash:8].[ext]’,​ &#x2F;&#x2F; 这里单位为(b) 10240 &#x3D;&gt; 10kb​ &#x2F;&#x2F; 这里如果小于10kb则转换为base64打包进js文件，如果大于10kb则打包到对应目录​ limit: 10240,​ }​ }​ ]​ }​ ]​ }​ }​ ​ 6.postcss-loader + autofixer​ postcss-loader可以做css兼容处理或者压缩css，postcss-loader相当于一个盒子，里面没什么功能，还需要借助autofixer来做css兼容​ 配置 Autoprefixer 之前，需要先添加 Browserslist ：在项目根目录添加 .browserslistrc 文件；或者在package.json文件中添加 browserslist​ ，比如：​ {​ “browserslist”: [​ “defaults”​ ]​ }​ 配置 Autoprefixer： ​ ​ ​ ​ 如果是在项目根目录中创建了 postcss.config.js：​ module.exports &#x3D; {​ plugins: [​ require(‘autoprefixer’)​ ]​ }​ 复制代码​ ​ 如果直接在 webpack.config.js 中配置：​ {​ test: &#x2F;.css$&#x2F;,​ use: [​ ‘style-loader’,​ ‘css-loader’,​ {​ loader: ‘postcss-loader’,​ options: {​ plugins: [​ require(‘autoprefixer’)​ ]​ }​ }​ ]​ }​ 例如你还用了sass的话，要在postcss-loader下面在添加个sass-loader了，且顺序不能错​ 生产模式中压缩CSS​ 推荐使用文件 postcss.config.js的方式:​ module.exports &#x3D; ({ env }) &#x3D;&gt; ({​ plugins: [​ require(‘autoprefixer’),​ env &#x3D;&#x3D;&#x3D; ‘production’ ? require(‘cssnano’) : null​ ]​ })​ 复制代码env取值process.env.NODE_ENV，可用来判断是开发模式还是生产模式。​ 当然也可以在 webpack.config.js 中，只是写起来有点冗余，尤其是需要在多个规则中用到 postcss-loader 时：​ const devMode &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; ‘development’; &#x2F;&#x2F; 是否是开发模式​ ​ module.exports &#x3D; {​ module: {​ rules:[​ {​ test: &#x2F;.css$&#x2F;,​ use: [​ ‘style-loader’,​ ‘css-loader’,​ {​ loader: ‘postcss-loader’,​ options: {​ plugins:devMode?[require(‘autoprefixer’)]​ :[require(‘autoprefixer’), require(‘cssnano’)]​ }​ }​ ],​ }​ ]​ }​ };​ 7.babel-loader​ ​ npm install -D babel-loader @babel&#x2F;core @babel&#x2F;preset-env​ 这是js兼容处理的loader，因为像promise，array.from等这些比较新的东西，旧的浏览器识别不了​ ​ babel-loader：在webpack里应用 babel 解析ES6的桥梁​ ​ @babel&#x2F;core：babel核心模块​ ​ @babel&#x2F;preset-env：babel预设，内置一组 babel 插件的集合​ ​ 在 webpack 配置对象中，需要将 babel-loader 添加到 module 列表中，就像下面这样​ webpack.config.js module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, // 排除编译 node_modules use: &#123; loader: &#39;babel-loader&#39;, options: &#123; presets: [&#39;@babel/preset-env&#39;] &#125; &#125; &#125; ] &#125; babel-loader也只能够处理一些比较简单的es6新东西，例如let const ts等等，因此还需要用polyfill 但是polyfill会将整个包都载入，不管有没有用到新语法，解决办法是让其按需加载更多 core.js可以做到 &#123; test:/\\.js$/, use:&#123; loader:&#39;babel-loader&#39;, options:&#123; presets:[ [&#39;@babel/preset-env&#39;, &#123; useBuiltIns:&#39;usage&#39;,//按需引入需要使用polyfill corejs:&#123; version:3 &#125;,//解决warn 指定corejs版本 targets:&#123;//指定兼容性处理那些浏览器 &quot;chrome&quot;:&quot;58&quot;, &quot;ie&quot;:&quot;9&quot; &#125; &#125; ] ] cacheDirectory:true,//开启缓存 &#125; &#125; &#125; 常用plugin 1.html-webpack-plugin 基本作用是生成html文件 ​ ​ 单页应用可以生成一个html入口，多页应用可以配置多个html-webpack-plugin实例来生成多个页面入口 ​ ​ 为html引入外部资源如script、link，将entry配置的相关入口chunk以及mini-css-extract-plugin抽取的css文件插入到基于该插件设置的template文件生成的html文件里面，具体的方式是link插入到head中，script插入到head或body中。 ​ ​ const HtmlWebpackPlugin &#x3D; require(‘html-webpack-plugin’);​ ​ module.exports &#x3D; {​ entry: {​ news: [path.resolve(__dirname, ‘..&#x2F;src&#x2F;news&#x2F;index.js’)],​ video: path.resolve(__dirname, ‘..&#x2F;src&#x2F;video&#x2F;index.js’),​ },​ plugins: [​ new HtmlWebpackPlugin({​ title: ‘news page’,​ &#x2F;&#x2F; 生成的文件名称 相对于webpackConfig.output.path路径而言​ filename: ‘pages&#x2F;news.html’,​ &#x2F;&#x2F; 生成filename的文件模板​ template: path.resolve(__dirname, ‘..&#x2F;template&#x2F;news&#x2F;index.html’),​ chunks: [‘news’]​ ​ }),​ new HtmlWebpackPlugin({​ title: ‘video page’,​ &#x2F;&#x2F; 生成的文件名称​ filename: ‘pages&#x2F;video.html’,​ &#x2F;&#x2F; 生成filename的文件模板​ template: path.resolve(__dirname, ‘..&#x2F;template&#x2F;video&#x2F;index.html’),​ chunks: [‘video’]​ }),​ ]​ };​ ​ 2. clean-webpack-plugin​ 默认情况下，这个插件会删除webpack的output.path中的所有文件，以及每次成功重新构建后所有未使用的资源。​ 这个插件在生产环境用的频率非常高，因为生产环境经常会通过 hash 生成很多 bundle 文件，如果不进行清理的话每次都会生成新的，导致文件夹非常庞大。​ const { CleanWebpackPlugin } &#x3D; require(‘clean-webpack-plugin’);​ module.exports &#x3D; {​ plugins: [​ new CleanWebpackPlugin(),​ ]​ };​ ​ 3.mini-css-extract-plugin​ 本插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件。​ &#x2F;&#x2F; 建议 mini-css-extract-plugin 与 css-loader 一起使用​ &#x2F;&#x2F; 将 loader 与 plugin 添加到 webpack 配置文件中​ const MiniCssExtractPlugin &#x3D; require(‘mini-css-extract-plugin’);​ ​ module.exports &#x3D; {​ plugins: [new MiniCssExtractPlugin()],​ module: {​ rules: [​ {​ test: &#x2F;.css$&#x2F;i,​ use: [MiniCssExtractPlugin.loader, ‘css-loader’],​ ​ }​ ],​ },​ }; webpack优化 优化配置loader 通过设置test&#x2F;include&#x2F;exclude来优化打包速度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748rules: [ &#123; test: /\\.css$/, include: path.resolve(__dirname, &quot;./src&quot;), use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, include: path.resolve(__dirname, &quot;./src&quot;), use: [ // &quot;style-loader&quot;, MiniCssExtractPlugin.loader, &#123; loader: &quot;css-loader&quot;, options: &#123; //css modules 开启 modules: true, &#125;, &#125;, &#123; loader: &quot;postcss-loader&quot;, &#125;, &quot;less-loader&quot;, ], &#125;, &#123; test: /\\.(png|jpe?g|gif)$/, include: path.resolve(__dirname, &quot;./src&quot;), use: &#123; loader: &quot;url-loader&quot;, options: &#123; name: &quot;[name]_[hash:6].[ext]&quot;, outputPath: &quot;images/&quot;, //推荐使用url-loader 因为url-loader支持limit //推荐小体积的图片资源转成base64 limit: 12 * 1024, //单位是字节 1024=1kb &#125;, &#125;, &#125;, &#123; test: /\\.js$/, include: path.resolve(__dirname, &quot;./src&quot;), exclude: /node_modules/, use: &#123; loader: &quot;babel-loader&quot;, &#125;, &#125;, ], 12345678优化resolve.modulesresolve.modules用于配置webpack去哪些目录下寻找第三方模块，默认是 [&#x27;node_modules&#x27;]。寻找第三方，默认是在当前项目目录下的node_modules里面去找，如果没有找到，就会去上一级目录../node_modules找，再没有会去../../node_modules中找，以此类推，和Node.js的模块寻找机制很类似。如果我们的第三⽅模块都安装在了项⽬根⽬录下，就可以直接指明这个路径。module.exports=&#123; resolve:&#123; modules: [path.resolve(__dirname, &quot;./node_modules&quot;)] &#125;&#125; 优化resolve.extensionsresolve.extensions在导⼊语句没带⽂件后缀时，webpack会⾃动带上后缀后，去尝试查找⽂件是否存在。 默认值： 12extensions:[&#x27;.js&#x27;,&#x27;.json&#x27;,&#x27;.jsx&#x27;,&#x27;.ts&#x27;]复制代码 后缀尝试列表尽量的⼩ 导⼊语句尽量的带上后缀。 如果想优化到极致的话，不建议用extensionx, 因为它会消耗一些性能。虽然它可以带来一些便利。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"vue结合XLSX简单实现excel表格的导入导出","slug":"vue结合XLSX简单实现excel表格的导入导出","date":"2022-03-06T04:16:12.000Z","updated":"2023-02-14T15:50:00.877Z","comments":true,"path":"2022/03/06/vue结合XLSX简单实现excel表格的导入导出/","link":"","permalink":"http://example.com/2022/03/06/vue%E7%BB%93%E5%90%88XLSX%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0excel%E8%A1%A8%E6%A0%BC%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"vue结合XLSX简单实现excel表格的导入导出 关于表格的导入导出实现，粗略地记录一下，备忘录了属于是。 表格的导入导出可以做的复杂也可以做的简单，这需要看需求。 前端想简单的话，可以让后端来干，前端负责调用后端提供的接口。 导入 弄个input标签 file类型接收文件，然后将文件上传给后端即可。 导出 123456let ele = document.createElement(&#x27;a&#x27;);ele.href = url;ele.style.display = &#x27;none&#x27;;document.body.appendChild(ele);ele.click();document.body.removeChild(ele); XLSX以及Blob、ArrayBuffer、FileReader这些东西我都忘光了 &#x3D; &#x3D; 如果工作前端来做的话（简单做个demo实现） 1、安装XLSX 1npm install xlsx file-saver --save 2、导入 12345678910111213141516171819202122232425262728//excel表格的导入就是 获取file 通过FileReader转ArrayBuffer,然后再通过XLSX.read()方法获得workbook 然后 function inputchange()&#123; if(columns.value.length!=0)&#123;columns.value.length = 0&#125; let input_getfile:any = document.querySelector(&#x27;#input_getfile&#x27;); let file = input_getfile.files[0];//获取文件 let reader = new FileReader(); reader.readAsArrayBuffer(file);//以二进制的形式读取文件 reader.onload = (e)=&gt;&#123; if(!(e.target?.result instanceof ArrayBuffer))&#123;return new Error(&#x27;类型错误&#x27;)&#125; excelArrayBuffer = (e.target?.result); const workbook =XLSX.read(excelArrayBuffer,&#123;type:&#x27;array&#x27;&#125;);//将excel转workbook const sheetNames:any = workbook.SheetNames;//返回一个数组，数组里面是sheet的名称，可能含有多个sheet，这得看excel里有多少个sheet了 //如果含有多个sheet 可以使用数组的map方法，const result = sheetNames.map((sheetName) =&gt; workbook.Sheets[sheetName]); //获取每个sheet //下面我只做了一个sheet页面的展示，如果你的excel表格是多个sheet的话，可以将每个sheet数据转json存放在一个数组上 //将每个sheet的key也存放在一个数组上 //然后表格数据展示通过v-for就可以了 const result = sheetNames.map((sheetName:any) =&gt; workbook.Sheets[sheetName]); let tableJson:any = XLSX.utils.sheet_to_json(result[0]);//sheet页转json dataSource.value = tableJson;//将sheet转化的json赋值给表格作为数据 for (let key in tableJson[0])&#123;//获取表头 let colu = new ColShape(); colu.title = key; colu.dataIndex = key; colu.key = key; columns.value.push(colu); &#125; 3、导出 123456789101112131415161718//导出当前页面数据，excel格式 function expTable()&#123; const el = document.querySelector(&quot;.ant-table-wrapper&quot;);//获取table表格展示的dom节点 if(!el)&#123;return&#125; const fileName = &#x27;example.xlsx&#x27;;//导出的文件名 const options = &#123; raw: true &#125;; //table_to_book()表示把页面上已有的表格dom节点传入（也可以动态js生成），直接返回一个workbook对象 const workbook = XLSX.utils.table_to_book(el, options); XLSX.writeFile(workbook, fileName, &#123; type: &#x27;binary&#x27; &#125;);//导出表格 &#125; //导出所有数据，excel格式 function expAllTable()&#123; if(!dataSource.value.length)&#123;return&#125; let ws = XLSX.utils.json_to_sheet(dataSource.value);//将数据转化为一个sheet let wb = XLSX.utils.book_new();//创建workbook对象，workbook对象对应的其实就是一个excel表格 XLSX.utils.book_append_sheet(wb, ws, &#x27;sheet&#x27;)// 添加worksheet 到 workbook XLSX.writeFile(wb, &#x27;alldata.xlsx&#x27;, &#123; type: &#x27;binary&#x27; &#125;);//writeFile()生成excel表格 &#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"关于Vue2的个人笔记","slug":"关于Vue2的个人笔记","date":"2022-02-02T04:16:12.000Z","updated":"2023-02-14T14:56:02.733Z","comments":true,"path":"2022/02/02/关于Vue2的个人笔记/","link":"","permalink":"http://example.com/2022/02/02/%E5%85%B3%E4%BA%8EVue2%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1.vue指令v-on：绑定事件，语法糖@ v-for：循环遍历数据，数据类型可以是 array|object|string|number ,特定语法，v-for&#x3D;“item in 数据源名” 或者 v-for&#x3D;“（item，index）in 数据源名” item可以自己起名，index是索引。v-for一般配合key来用，key是为了能够更好的利用性能，高效地选择渲染。一般是 ：key&#x3D;“”，：其实就是v-bind:key&#x3D;””,v-for一般不与v-if公用，因为v-for优先级比v-if高，这样渲染起来很浪费性能。 v-show：根绝true或false来觉得内容是否显示，它与v-if区别是，v-show实际是绑定display：none。v-if是真实的渲染与销毁。 v-bind：动态绑定，语法糖是“ ：” v-if：根绝true或false来觉得是否渲染 v-else：配合v-if使用 v-model：双向绑定，限制在input、select、textarea、components中使用 用于数据的双向绑定操作. v-once：执行一次性插值，当数据改变时，插值处内容仍不变。 2.vuex（状态管理模式）2.1 vuex五大核心概念state：用于数据存储，类似于组件中的data mutations：state的数据增改都要通过mutations， getters：类似组件的computed计算属性一样，数据会缓存起来，当依赖的数据发了变化时，才会从新计算。目的在于提高性能。 actions：类似于mutations，action提交的是 mutation，而不是直接变更状态。 modules：当数据操作太大太多时，可能就需要分模块了，而modules就是起到分块的角色。 2.2 vuex的安装使用vuex的使用，npm下载vuex，或者手脚架create vue项目时，选择vuex 初始化store下的index.js内容 1234567891011121314151617在vue项目目录创建store目录，在创建index.js配置文件。其中内容如下import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;//挂载VuexVue.use(Vuex)//创建VueX对象const store = new Vuex.Store(&#123; state:&#123; //存放的键值对就是所要管理的状态 name:&#x27;helloVueX&#x27; &#125;&#125;)export default store 将store挂载到vue实例上，在main.js文件中 1234567891011121314import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: &#x27;#app&#x27;, router, store, //store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中 render: h =&gt; h(App)&#125;) 2.3 访问state属性在组件中使用vuex，通过大胡子语法糖，$store.state.name直接访问state中的name属性 123456&lt;template&gt; &lt;div id=&#x27;app&#x27;&gt; name: &lt;h1&gt;&#123;&#123; $store.state.name &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 或者在组件方法中访问state属性 1234567...,methods:&#123; add()&#123; console.log(this.$store.state.name) &#125;&#125;,... 2.4 mutation使用方法设置、修改state属性值， 12345678910111213141516171819202122232425import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)const store = new Vuex.store(&#123; state:&#123; name:&#x27;helloVueX&#x27; &#125;, mutations:&#123; //es6语法，等同edit:funcion()&#123;...&#125; edit(state，payload)&#123; state.name = &#x27;jack&#x27; &#125;， increment (state, payload) &#123; state.count += payload.amount &#125; &#125;&#125;)export default store//提交载荷（Payload）你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读： 而在组件中，我们需要这样去调用这个mutation——例如在App.vue的某个method中: 12345678910111213141516171819202122232425this.$store.commit(&#x27;edit&#x27;，参数)this.$store.commit(&#x27;increment&#x27;，payload)commit中的方法名edit与mutations中的edit对应才行单个值提交时:this.$store.commit(&#x27;edit&#x27;,15)当需要多参提交时，推荐把他们放在一个对象中来提交:this.$store.commit(&#x27;edit&#x27;,&#123;age:15,sex:&#x27;男&#x27;&#125;)接收挂载的参数：edit(state,payload)&#123; state.name = &#x27;jack&#x27; console.log(payload) // 15或&#123;age:15,sex:&#x27;男&#x27;&#125; &#125;另一种提交方式this.$store.commit(&#123; type:&#x27;edit&#x27;, payload:&#123; age:15, sex:&#x27;男&#x27; &#125;&#125;) 2.5增删state中的成员为了配合Vue的响应式数据，我们在Mutations的方法中，应当使用Vue提供的方法来进行操作。如果使用delete或者xx.xx = xx的形式去删或增，则Vue不能对数据进行实时响应。 Vue.set 为某个对象设置成员的值，若不存在则新增 例如对state对象中添加一个age成员 1Vue.set(state,&quot;age&quot;,15) Vue.delete 删除成员 将刚刚添加的age成员删除 1Vue.delete(state,&#x27;age&#x27;) 2.6 getters可以对state中的成员加工后传递给外界 Getters中的方法有两个默认参数 state 当前VueX对象中的状态对象 getters 当前getters对象，用于将getters下的其他getter拿来用 12345678getters:&#123; nameInfo(state)&#123; return &quot;姓名:&quot;+state.name &#125;, fullInfo(state,getters)&#123; return getters.nameInfo+&#x27;年龄:&#x27;+state.age &#125; &#125; 组件中调用 1this.$store.getters.fullInfo 2.7 actions由于直接在mutation方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交mutation方法。 Actions中的方法有两个默认参数 context 上下文(相当于箭头函数中的this)对象 payload 挂载参数 例如，我们在两秒中后执行2.2.2节中的edit方法 由于setTimeout是异步操作，所以需要使用actions 1234567actions:&#123; aEdit(context,payload)&#123; setTimeout(()=&gt;&#123; context.commit(&#x27;edit&#x27;,payload) &#125;,2000) &#125;&#125; 在组件中调用: 1this.$store.dispatch(&#x27;aEdit&#x27;,&#123;age:15&#125;) 改进: 由于是异步操作，所以我们可以为我们的异步操作封装为一个Promise对象 12345678aEdit(context,payload)&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; context.commit(&#x27;edit&#x27;,payload) resolve() &#125;,2000) &#125;)&#125; 2.8 modules当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。 1234567modules:&#123; a:&#123; state:&#123;&#125;, getters:&#123;&#125;, .... &#125;&#125; 组件内调用模块a的状态： 1this.$store.state.a 而提交或者dispatch某个方法和以前一样,会自动执行所有模块内的对应type的方法： 12this.$store.commit(&#x27;editKey&#x27;)this.$store.dispatch(&#x27;aEditKey&#x27;) 3.vue生命周期beforeCreate创建前 created已创建 beforeMount挂载前 mounted已挂载 beforeUpdate更新前 updated已更新 beforeDestroy销毁前 destroyed已销毁 3.1 beforeCreate请求数据一般在created或者mounted，因为beforeCreate时，还没实例化，组件对象还被创建，el和data还没被初始化，因此methods，data，computed等无法被访问。 3.2 created实例已创建完之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch&#x2F;event事件回调，完成了data 数据的初始化，el没有，$el属性目前不可见。created是一个被常用的生命周期，因为这时已经可以调用method中的方法了，改变data中的数据了，并且修改可以通过vue的响应式绑定体现在页面上，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成。 3.3 beforeMount挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。 3.4 mounted挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次 3.5 beforeUpdate在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程 3.6 updated（更新后）在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用 3.7 beforeDestroy（销毁前）在实例销毁之前调用，实例仍然完全可用， 这一步还可以用this来获取实例， 一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件 3.8 destroyed（销毁后）在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用 4.vue-router路由中有三个基本的概念 route, routes, router。 1， route，它是一条路由，由这个英文单词也可以看出来，它是单数， Home按钮 &#x3D;&gt; home内容， 这是一条route, about按钮 &#x3D;&gt; about 内容， 这是另一条路由。 2， routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 &#x3D;&gt;home内容 }， { about按钮 &#x3D;&gt; about 内容}] 3， router 是一个机制，相当于一个管理者，它来管理路由。因为routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。 vue-router提供两种方式hash和history，根据mode参数来选择。 4.1 hashhash模式url里面永远带着#号，开发当中默认使用这个模式。 4.2 history如果用户考虑url的规范那么就需要使用history模式，因为history模式没有#号，是个正常的url，适合推广宣传 4.3 vue-router使用方式1.npm下载npm i vue-router -S 2.在vue项目创建目录router，index.js文件配置 3.main.js文件中引入，并使用 4.4 在main.js文件中123456789import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 4.5 在router目录index.js文件中123456789101112131415161718192021222324252627282930313233343536import Vue from &#x27;vue&#x27;//引入Vueimport VueRouter from &#x27;vue-router&#x27;//引入vue-router// import find from &#x27;../components/Home&#x27;//引入根目录下的Home.vue组件// import find from &#x27;../views/find/find&#x27; //以上这两个是路由//const find = ()=&gt;import(&#x27;../views/find/find.vue&#x27;)//路由懒加载的写法Vue.use(VueRouter)//Vue全局使用Routerconst routes = [//配置路由，这里是个数组 &#123;//每一个链接都是一个对象 path:&#x27;&#x27;, redirect:&#x27;/find&#x27;, //路由重定向 &#125;, &#123; path:&#x27;/find&#x27;,//链接路径 name:&#x27;find&#x27;,//路由名称， component:find,//对应的组件模板 meta:&#123; keepAlive:true, //true表示该路由进行keepAlive缓存 &#125;, ]const router = new VueRouter(&#123; mode: &#x27;history&#x27;, // base: process.env.BASE_URL, routes, &#125;)export default router 4.6 组件中使用路由路由标签 12345678910111213&lt;router-link to=&quot;/find&quot;&gt;&lt;/router-link&gt; 当路由标签处于活跃时，会自动生成一个class，一般用于样式修改to代表跳转到哪个路由 router-link标签默认被渲染成一个带有链接的a标签，可以通过设置来让其变成其他标签，通过to属性来指定链接地址&lt;router-view &gt;&lt;/router-view&gt;表示路由内容展示的位置，&lt;keep-alive&gt;&lt;/keep-alive&gt;让路由组件有一个缓存，再次打开该路由时，一些dom操作仍然保持着。使用方式：&lt;keep-alive&gt;&lt;router-view &gt;&lt;/router-view&gt;&lt;/keep-alive&gt;可以给路由组件配置一些属性，让其根据需求来动态的使用&lt;keep-alive&gt;&lt;/keep-alive&gt;，优化性能 4.7 动态路由匹配例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』来达到这个效果。 1234567891011121314const User = &#123; template: &#x27;&lt;div&gt;User&lt;/div&gt;&#x27;&#125; const router = new VueRouter(&#123; routes: [ // 动态路径参数 以冒号开头 &#123; path: &#x27;/user/:id&#x27;, component: User &#125; ]&#125;)例如： /user/foo 和 /user/bar 都将映射到相同的路由。一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到this.$route.params，可以在每个组件内使用。你可以在一个路由中设置多段『路径参数』，对应的值都会设置到 $route.params 中。例如： 4.8 vue-router路由传参1.name值传参 123456789&#123; path:&#x27;/find&#x27;,//链接路径 name:&#x27;find&#x27;,//路由名称， component:find,//对应的组件模板 meta:&#123; keepAlive:true, //true表示该路由进行keepAlive缓存 &#125;, $router.name 2.通过 标签中的to传参 1&lt;router-link :to=&quot;&#123;name:‘dxl’,params:&#123;key:value&#125;&#125;&quot;&gt;东西里&lt;/router-link&gt; name：就是我们在路由配置文件中起的name值。另：命名路由就是用一个名称来标识一个路由，在定义路由的时候设置一个name属性即可。在router-link中也可以用路由的名字来链接到一个路由。 params：就是我们要传的参数，它也是对象形势，在对象里可以传递多个值。最后用$route.params.username进行接收. 3.用url传参 (1).在router路由配置文件里以冒号的形式设置参数 1234&#123; path:&#x27;/params/:newsId/:userName, component:Params&#125; (2).组件形式，在src&#x2F;components目录下建立我们params.vue组件。我们在页面里输出了url传递的参数。 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;p&gt;新闻ID：&#123;&#123; $route.params.newsId&#125;&#125;&lt;/p&gt; &lt;p&gt;用户名：&#123;&#123; $route.params.userName&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;params&#x27;, data () &#123; return &#123; msg: &#x27;params page&#x27; &#125; &#125;&#125;&lt;/script&gt; (3).标签path路径中传值 12&lt;router-link to=&quot;/params/888/dxl shuai&gt;params&lt;/router-link&gt; 路由组件传参 在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。 解耦前： id不能直接拿出来使用 12345678910const User = &#123; template: &#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/user/:id&#x27;, component: User &#125; ]&#125;) 使用 props 将组件和路由解耦： 1234567891011121314151617const User = &#123; props: [&#x27;id&#x27;], template: &#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/user/:id&#x27;, component: User, props: true &#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: &#x27;/user/:id&#x27;, components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 这样你便可以在任何地方使用该组件，使得该组件更易于重用和测试 1.布尔模式如果 props 被设置为 true，route.params 将会被设置为组件属性。 2.对象模式如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。 3.函数模式你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。 12345const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/search&#x27;, component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125; ]&#125;) 4.9 路由钩子1.路由配置文件中的钩子函数： 在路由文件中我们只能写一个beforeEnter,就是在进入此路由配置时： 123456789101112131415&#123; path:&#x27;/params/:newsId(\\\\d+)/:userName&#x27;, component:Params, beforeEnter:(to,from,next)=&gt;&#123; console.log(&#x27;我进入了params模板&#x27;); console.log(to); console.log(from); next();&#125;,三个参数：to:路由将要跳转的路径信息，信息是包含在对像里边的。from:路径跳转前的路径信息，也是一个对象的形式。next:路由的控制参数，常用的有next(true)和next(false)。 2.写在模板中的钩子函数：写在模板中就可以有两个钩子函数可以使用。beforeRouteEnter：在路由进入前的钩子函数。beforeRouteLeave：在路由离开前的钩子函数。 1234567891011121314151617export default &#123; name: &#x27;params&#x27;, data () &#123; return &#123; msg: &#x27;params page&#x27; &#125; &#125;, beforeRouteEnter:(to,from,next)=&gt;&#123; console.log(&quot;准备进入路由模板&quot;); next(); &#125;, beforeRouteLeave: (to, from, next) =&gt; &#123; console.log(&quot;准备离开路由模板&quot;); next(); &#125;&#125; ★此处常用于数据获取。 导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示『加载中』之类的指示。当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。假设我们有一个 Post 组件，需要基于 $route.params.id 获取文章数据： &#96;&#96;&#96; Loading... export default { data () { return { loading: false, post: null, error: null } }, created () { // 组件创建完后获取数据， // 此时 data 已经被 observed 了 this.fetchData() }, watch: { // 如果路由有变化，会再次执行该方法 '$route': 'fetchData' }, methods: { fetchData () { this.error = this.post = null this.loading = true // replace getPost with your data fetching util / API wrapper getPost(this.$route.params.id, (err, post) => { this.loading = false if (err) { this.error = err.toString() } else { this.post = post } }) } } } 1234- **导航完成之前获取**：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后再执行导航。 通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 beforeRouteEnter 守卫中获取数据，当数据获取成功后只调用 next 方法。 export default { data () { return { post: null, error: null } }, beforeRouteEnter (to, from, next) { getPost(to.params.id, (err, post) => { next(vm => vm.setData(err, post)) }) }, // 路由改变前，组件就已经渲染完了 // 逻辑稍稍不同 beforeRouteUpdate (to, from, next) { this.post = null getPost(to.params.id, (err, post) => { this.setData(err, post) next() }) }, methods: { setData (err, post) { if (err) { this.error = err.toString() } else { this.post = post } } } } 123456789101112131415161718192021222324- ### 编程式导航- ``` 1 第一个知识 编程式导航/编程式路由 this.$router.push(&#x27;/路径&#x27;) // myname是组件名称，用&#123;&#123;$route.params.age&#125;&#125;在myname组件中获取传过来的值 this.$router.push(&#123;name:&#x27;myname&#x27;,params:&#123;age:100&#125;&#125;) //用&#123;&#123;$route.query.userid&#125;&#125;在新组件中获取传过来的值 this.$router.psuh(&#123;path:&#x27;不加/ 直接写路径&#x27;,query:&#123;userid:100&#125;&#125;) 2 前进与后退,正数前进 负数后退 this.$router.go(数字) 3 转换 hash 模式 与h5 模式 默认是hash 模式 mode: &#x27;history&#x27;, /* 表示 H5 的模式*/ 4 动态 router-link , name是组件的name router.push router.replace router.go 这些是效仿window.history api 上面路由传参不够简洁，so： vue路由传参的三种方式：第一种方法 页面刷新数据不会丢失 1234567methods：&#123; insurance(id) &#123; //直接调用$router.push 实现携带参数的跳转 this.$router.push(&#123; path: `/particulars/$&#123;id&#125;`, &#125;)&#125; 需要对应路由配置如下： 12345&#123; path: &#x27;/particulars/:id&#x27;, name: &#x27;particulars&#x27;, component: particulars &#125; 可以看出需要在path中添加&#x2F;:id来对应 $router.push 中path携带的参数。在子组件中可以使用来获取传递的参数值另外页面获取参数如下 1this.$route.params.id 第二种方法 页面刷新数据会丢失 通过路由属性中的name来确定匹配的路由，通过params来传递参数。 123456789methods：&#123; insurance(id) &#123; this.$router.push(&#123; name: &#x27;particulars&#x27;, params: &#123; id: id &#125; &#125;) &#125; 对应路由配置: 注意这里不能使用:&#x2F;id来传递参数了，因为组件中，已经使用params来携带参数了。 12345&#123; path: &#x27;/particulars&#x27;, name: &#x27;particulars&#x27;, component: particulars &#125; 子组件中: 这样来获取参数 1this.$route.params.id 第三种方法 使用path来匹配路由，然后通过query来传递参数这种情况下 query传递的参数会显示在url后面?id&#x3D;？ 123456789methods：&#123; insurance(id) &#123; this.$router.push(&#123; path: &#x27;/particulars&#x27;, query: &#123; id: id &#125; &#125;) &#125; 对应路由配置： 12345&#123; path: &#x27;/particulars&#x27;, name: &#x27;particulars&#x27;, component: particulars &#125; 对应子组件: 这样来获取参数 1this.$route.query.id 特别注意哦，组件中 获取参数的时候是route.params而不是router。 5.组件通信5.1 父传子子组件使用props接收 接收时还可以设置默认值 当没获取到值时 会使用设置的默认值 123456789101112131415161718192021父组件&lt;template&gt; &lt;div&gt; &lt;child :tochild=&quot;parentVal&quot;&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from &quot;@/components/child&quot;; export default &#123; name: &#x27;parent&#x27;, data () &#123; return &#123; parentVal: &#x27;parent&#x27;, &#125; &#125;, components: &#123; child &#125;&#125;&lt;/script&gt; 1234567891011121314子组件&lt;template&gt; &lt;div&gt; &lt;p&gt;父级传过来的值：&#123;&#123;tochild&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;child&#x27;, props: &#123; tochild: String &#125;&#125;&lt;/script&gt; 5.2 子传父123456789101112131415在子组件中&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;toParent&quot;&gt;点击传到父级&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; name: &#x27;child&#x27;, methods: &#123; toParent () &#123; this.$emit(&#x27;fromChild&#x27;, &#x27;child&#x27;) //child代表参数 &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021222324252627父组件中&lt;template&gt; &lt;div&gt; &lt;p&gt;子级传过来的值：&#123;&#123;childVal&#125;&#125;&lt;/p&gt; &lt;child @fromChild=&quot;getChild&quot;&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from &quot;@/components/child&quot;; export default &#123; name: &#x27;parent&#x27;, data () &#123; return &#123; childVal: &#x27;&#x27; &#125; &#125;, components: &#123; child &#125;, methods: &#123; getChild (v) &#123; this.childVal = v; &#125; &#125;&#125;&lt;/script&gt; 5.3 Vuex上面写了。 5.4 事件总线（EventBus） 一、全局事件总线 创建全局事件总线，在main.js 中创建 1234567891011// 创建写法1：let EventBus = new Vue() //vue实例可以作为事件总线Object.defineProperties(Vue.prototype,&#123; $bus:&#123; get()&#123; return EventBus &#125; &#125;&#125;)// 创建写法2：Vue.prototype.$Bus = new Vue() 在组件中基于全局事件总线中发送和监听事件 12345this.$bus.$emit(&#x27;nameOfEvent&#x27;, &#123; ... pass some event data ...&#125;); this.$bus.$on(&#x27;nameOfEvent&#x27;,($event) =&gt; &#123; // ...&#125;) 二、事件总线 创建一个单独的event-bus.js文件 1234//引入vue模块import Vue from &#x27;vue&#x27;let EventBus = new Vue()export default EventBus 在组件中基于事件中线发送事件&#x2F;&#x2F;a.js import EventBus from event-bus.js //发送事件，第二个参数可选 EventBus.$on(\"aMsg\", (msg) => { // 发送来的消息 this.msg = msg; }); } 在组件中基于事件总线监听事件 1234567//b.js&lt;script&gt; import EventBus from event-bus.jsEventBus.$on(&quot;aMsg&quot;,(msg)=&gt;&#123;// do something&#125;)&lt;/script&gt; 三、移除事件监听 vue是单页应用，如果你在某一个页面刷新了之后，与之相关的EventBus会被移除，这样就导致业务走不下去。还有就是如果业务有反复操作的页面，EventBus 在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理 EventBus 在项目中的关系。通常会用到，在vue页面销毁时，同时移除EventBus 事件监听。 123456789101112131415161718&lt;script&gt;import EventBus from event-bus.js //移除事件监听者 // 最好在组件销毁前beforeDestroy: function () &#123; eventBus.$off(&#x27;add-todo&#x27;, this.addTodo) eventBus.$off(&#x27;delete-todo&#x27;, this.deleteTodo) //两个参数&#125;,methods: &#123; addTodo: function (newTodo) &#123; this.todos.push(newTodo) &#125;, deleteTodo: function (todoId) &#123; this.todos = this.todos.filter(function (todo) &#123; return todo.id !== todoId &#125;) &#125;&lt;/script&gt; EventBus.$off() ———–移除当前组件的所有事件监听者 EventBus.$off(param:string)————移除当前组件对某个事件的所有监听 EventBus.$off(param:string,param)——-移除某个方法对某个事件的监听如 5.5 路由传参在第四部分有讲解。 6.ref基本用法，本页获取dom元素 12345678910111213141516&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div ref=&quot;testDom&quot;&gt;11111&lt;/div&gt; &lt;button @click=&quot;getTest&quot;&gt;获取test节点&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; getTest() &#123; console.log(this.$refs.testDom) &#125; &#125;&#125;;&lt;/script&gt; ref还可以获取子组件中的data和调用子组件中的方法 获取data 子组件 123456789101112131415&lt;template&gt; &lt;div&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; msg: &quot;hello world&quot; &#125; &#125;&#125;&lt;/script&gt; 父组件 123456789101112131415161718192021222324&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;HelloWorld ref=&quot;hello&quot;/&gt; &lt;button @click=&quot;getHello&quot;&gt;获取helloworld组件中的值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &quot;./components/HelloWorld.vue&quot;;export default &#123; components: &#123; HelloWorld &#125;, data() &#123; return &#123;&#125; &#125;, methods: &#123; getHello() &#123; console.log(this.$refs.hello.msg) &#125; &#125;&#125;;&lt;/script&gt; 获取子组件方法 子组件 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; open() &#123; console.log(&quot;调用到了&quot;) &#125; &#125;&#125;&lt;/script&gt; 父组件 123456789101112131415161718192021222324&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;HelloWorld ref=&quot;hello&quot;/&gt; &lt;button @click=&quot;getHello&quot;&gt;获取helloworld组件中的值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &quot;./components/HelloWorld.vue&quot;;export default &#123; components: &#123; HelloWorld &#125;, data() &#123; return &#123;&#125; &#125;, methods: &#123; getHello() &#123; this.$refs.hello.open(); &#125; &#125;&#125;;&lt;/script&gt; 7.导航守卫导航守卫分三类： 1.全局守卫 2.路由独享守卫 3.组件内守卫 一、全局守卫1.router.beforeEach((to,from,next&#x3D;&gt;{}) 2.回调函数中的参数，to：进入到哪个路由去，from：从哪个路由离开，next：next函数，决定是否展示你要看到的路由页面 3.例如：在main.js中设置全局守卫 在main.js中，有一个路由实例化对象router。在main.js中设置守卫已是全局守卫。 如下，判断to.path当前将要进入的路径是否为登录或注册，如果是就执行next()，展示当前界面。如果不是，就弹出alert，然后移至登录界面。 这样就可实现，用户在未登录状态下，展示的一直是登录界面。 12345678router.beforeEach((to,from,next)=&gt;&#123; if(to.path == &#x27;/login&#x27; || to.path == &#x27;/register&#x27;)&#123; next(); &#125;else&#123; alert(&#x27;您还没有登录，请先登录&#x27;); next(&#x27;/login&#x27;); &#125;&#125;) 4.全局后置钩子 router.afterEach(to,from&#x3D;&gt;{}) 只有两个参数，to：进入到哪个路由去，from：从哪个路由离。 如下，每次切换路由时，都会弹出alert，点击确定后，展示当前页面。 123router.afterEach((to,from)=&gt;&#123; alert(&quot;after each&quot;);&#125;) store.gettes.isLogin &#x3D;&#x3D;&#x3D; false 是否登录 二、组件内守卫1.到达这个组件时，beforeRouteEnter:(to,from,next)&#x3D;&gt;{} 在Admin.vue文件中，点击转到admin路由时，执行beforeRouteEnter函数 to，from参数与上面使用方法一致。next回调函数略有不同。 如下例，data 组件内守卫有特殊情况，如果我们直接以 beforeRouteEnter:(to,from,next)=&gt;&#123; alert(&quot;hello&quot; + this.name);&#125;进行访问admin页面，会发现alert输出hello undefined。这是因为，现在访问不到我们的data属性，执行顺序是不一致，这与的声明周期有关。在执行完之前，data数据还未渲染。所以这里，next()会给一个对应的回调，帮助完成。 123456789101112131415161718&lt;script&gt;export default &#123; data()&#123; return&#123; name:&quot;Arya&quot; &#125; &#125;, beforeRouteEnter:(to,from,next)=&gt;&#123; next(vm=&gt;&#123; alert(&quot;hello&quot; + vm.name); &#125;) &#125;&#125;&lt;/script&gt;// 在渲染该组件的对应路由被 confirm 前调用// 不！能！获取组件实例 `this`// 因为当守卫执行前，组件实例还没被创建 2.当前路由发生改变或者组件被复用时调用beforeRouteUpdate:(to,from,next)&#x3D;&gt;{} 123456beforeRouteUpdate(to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, 3.离开这个组件时，beforeRouteLeave:(to,from,next)&#x3D;&gt;{} 点击其他组件时，判断是否确认离开。确认执行next()；取消执行next(false)，留在当前页面。 1234567beforeRouteLeave:(to,from,next)=&gt;&#123; if(confirm(&quot;确定离开此页面吗？&quot;) == true)&#123; next(); &#125;else&#123; next(false); &#125; &#125; 三、路由独享守卫1.beforeEnter：(to,from,next)&#x3D;&gt;{},用法与全局守卫一样，只是将它用在其中一个路由对象中，只在这个路由起作用 1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/foo&#x27;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 所以导航守卫钩子函数执行的顺序为：beforeRouteLeave（上一个组件失活） –&gt; beforeEach –&gt; beforeEnter –&gt; beforeRouteEnter –&gt; beforeResolve –&gt; afterEach –&gt; beforeRouteUpdate（如果组件重复使用，否则不执行） –&gt; beforeRouteLeave（当前组件失活） 8.computed和watch8.1.计算属性computed支持缓存，当依赖的属性发生变化时，才会重新计算。若没改变，计算属性会立即返回之前缓存的计算结果。 不支持异步，当computed内有异步操作时无效，无法监听数据的变化。 computed 中的成员可以只定义一个函数作为只读属性, 也可以定义成 get&#x2F;set 变成可读写属性 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed。 8.2.watch不支持缓存，数据变化或者重新触发渲染时，直接触发响应操作。 watch 支持异步 当一个属性发生变化时，需要执行对应的操作；一对多时，一般用 watch。 监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数，immediate：组件加载立即触发回调函数执行，deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep 无法监听到数组的变动和对象的新增，参考 vue 数组变异,只有以响应式的方式触发才会被监听到。 9.插槽插槽的作用是让Vue组件更加的灵活与多样，就跟usb接口一样，让电脑可以更加灵活多样。 因为在2.6.0中，具名插槽 和 作用域插槽 引入了一个新的统一的语法 (即 v-slot 指令)，它取代了 slot 和 slot-scope。 说到插槽就离不开三样东西： 9.1默认插槽9.2具名插槽9.3插槽作用域纯粹个人理解 插槽作用域直白点说就是让父组件可以访问到子组件的属性，让显示的内容又子组件决定。 father.vue 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;son :mes=&quot;mes&quot; @sonTofather=&quot;sonTofather&quot;&gt; &lt;template slot-scope=&quot;&#123;games&#125;&quot;&gt; &lt;div v-for=&quot;(item,index) in games&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;/son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import son from &quot;./son.vue&quot;;export default &#123;name:&#x27;father&#x27;,components:&#123; son&#125;, data () &#123; return &#123; mes:&quot;父组件message&quot;, &#125; &#125;, methods: &#123; sonTofather(message)&#123; console.log(message); &#125; &#125;,&#125;&lt;/script&gt; son.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div class=&quot;son&quot;&gt; 子组件 &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name:&#x27;son&#x27;,props:[&#x27;mes&#x27;,&#x27;example&#x27;], data () &#123; return &#123; games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;], &#125; &#125;, methods: &#123; updataValue()&#123; this.$emit(&quot;sonTofather&quot;,&quot;子组件message&quot;); &#125; &#125;,&#125; 结果： 可以看出，父组件可以访问子组件里面的数据了，从而让子组件来决定展示什么样的数据了。","categories":[{"name":"Vue2","slug":"Vue2","permalink":"http://example.com/categories/Vue2/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"Vue2","permalink":"http://example.com/tags/Vue2/"}]},{"title":"关于我脱发那件事","slug":"关于我脱发那件事","date":"2022-02-02T04:16:12.000Z","updated":"2023-02-14T14:58:30.842Z","comments":true,"path":"2022/02/02/关于我脱发那件事/","link":"","permalink":"http://example.com/2022/02/02/%E5%85%B3%E4%BA%8E%E6%88%91%E8%84%B1%E5%8F%91%E9%82%A3%E4%BB%B6%E4%BA%8B/","excerpt":"","text":"我才没有脱发谢谢","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"git的常见操作","slug":"git常见操作","date":"2021-09-06T04:16:12.000Z","updated":"2023-02-14T14:43:48.318Z","comments":true,"path":"2021/09/06/git常见操作/","link":"","permalink":"http://example.com/2021/09/06/git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"","text":"git常见操作 12345678910111213141516171819202122232425git init 选择路径，在当前路径初始化，会创建一个隐藏的文件.git，把该目录变成git可以管理的仓库。git add . 点代表所有，add代表添加到暂存区。该语句为将该路径下的所有文件添加到暂存区中。git add 文件名 文件名需要全名，即后缀名也带上，表示添该文件到暂存区中git commit -m &quot;提交的注释&quot; 将在暂存区文件提交到仓库git status 显示工作目录和暂存区的状态使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被Git tracked到。git status不显示已经commit到项目历史中去的信息。看项目历史的信息要使用git log.git diff 文件名 查看文件修改的内容git log 查看历史记录，如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=onelinegit reset --hard HEAD^ 回退到上一个版本git reset --hard HEAD^^ 回退到上上一个版本git reset --hard HEAD~100 回退到前100个版本的git reset --hard 版本号 回退到指定版本 git reflog 查看版本号cat 文件名 查看文件内容rm 文件名 删除文件然后在commit就能将文件彻底的从版本库中删掉此文件git checkout -- 文件名 恢复文件，但是是在commit之前才能恢复。 123456789三：理解工作区与暂存区的区别？工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。我们前面说过使用Git提交文件到版本库有两步：第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 123456789101112131415在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset --hard HEAD^第三：git checkout -- 文件名 丢弃工作区的修改，命令 git checkout --readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：1.readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。2.另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。注意：命令git checkout -- readme.txt 中的 -- 很重要，如果没有 -- 的话，那么命令变成创建分支了。 1234567891011远程仓库git remote add origin 仓库地址 可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联git push 本地库内容推送到远程仓库，使用 git push命令，实际上是把当前分支master推送到远程。git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了从现在起，只要本地作了提交，就可以通过如下命令：git push origin master把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。从远程仓库克隆 git clone 项目地址 12345678910111213141516171819202122232425262728293031创建与合并分支在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。git checkout -b dev（分支名） 创建并切换分支git branch 查看分支，会列出所有分支git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令git branch devgit checkout devgit checkout master 切换到主分支git merge 分支名 将分支内容合并到分支master上，git branch -d 分支名 删除分支总结创建与合并分支命令如下：查看分支：git branch创建分支：git branch name切换分支：git checkout name创建+切换分支：git checkout –b name合并某分支到当前分支：git merge name删除分支：git branch –d name 1234pwd 查看当前路径dir 查看当前所在的文件所有文档 //并不能看到隐藏文件cd d： 直接进入d盘tab补全相关文件夹名或文件","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"dom相关","slug":"dom相关","date":"2021-06-06T04:16:12.000Z","updated":"2023-02-14T14:44:06.376Z","comments":true,"path":"2021/06/06/dom相关/","link":"","permalink":"http://example.com/2021/06/06/dom%E7%9B%B8%E5%85%B3/","excerpt":"","text":"dom相关dom即document object model. 1.获取元素的几种方法 doucment.getElementById(); document.getElementsByTagName(); document.getElementsByName(); document.getElementsByClassName(); document.querySelector() ; document.querySelectorAll(); doucment.getElementById() 获取文档流中id名称对应的一个元素 没有就是null document.getElementsByClassName() 获取文档流中所有的类名对应的元素 返回的是一个伪数组 如果没有元素就是空数组 哪怕只有一个元素，返回的也是个伪数组 document.getElementsByName() 可返回带有指定名称的对象的集合。 document.getElementsByTagName() 获取文档流中所有的标签名对应的元素 返回一个伪数组，没有则空 。一个也返回类型为数组 **document.querySelector() ** 获取文档流中满足选择器规则的 第一个 元素 返回值为第一个元素 没有则null 参数可以是id名 class名 以及标签名 document.querySelectorAll() 获取文档流中所有满足选择器规则的元素 返回一个伪数组 一个元素也为数组 没有则空 2.元素操作 操作元素内容 123操作元素文本内容 元素.innerText 元素.innerText = &#x27;新内容&#x27;操作元素超文本内容 元素.innerHTML 元素.innerHTML = &#x27;新内容&#x27; 该内容可以带有html标签的字符串，都可以解析出来，如&lt;span&gt;hhhh&lt;span/&gt; 操作元素属性 1234567原生属性 获取： 元素.属性名 设置： 元素.属性名 = &#x27;属性名&#x27;自定义属性 获取：元素.getAttribute(&#x27;属性名&#x27;)​ 设置：元素.setAttribute(&#x27;属性名&#x27;，‘属性值’)​ 删除：元素.removeAttribute(‘属性名’) 操作元素类名 123设置： 元素.setAttribute(&#x27;属性名&#x27;) 元素.setAttribute(&#x27;属性名&#x27;，‘属性值’)给元素添加多个类名 元素.classList.add(&quot;classssname1&quot;,&quot;classssname2&quot;,&quot;classssname3&quot;,) 操作元素行内样式 123获取：元素.style.样式名设置：元素.sytle.样式名 = &#x27;样式值&#x27; 获取元素非行内样式 1获取window.getComputedStyle(元素).样式名 注意：这样即可以获取行内也可以获取非行内样式 使用原生JS给元素–添加&#x2F;删除类名 1var dom = document.getElementById(&quot;idName&quot;); ​ 添加 单个 class: 1dom.classList.add(&quot;className1&quot;); 添加多个类: 1dom.classList.add(&quot;className1&quot;, &quot;className2&quot;, &quot;className3&quot;, ....., &quot;classNameN&quot;); 移除一个类: 1dom.classList.remove(&quot;className1&quot;); 移除多个类: 1dom.classList.remove(&quot;className1&quot;, &quot;className2&quot;, &quot;className3&quot;, ....., &quot;classNameN&quot;); 检查是否含有某个类 1dom.classList.contains(&#x27;className&#x27;); //return true or false 3.各种区域:12345678910111213141516171819202122232425262728293031323334353637383940网页可见区域宽： document.body.clientWidth 元素内容+padding区域尺寸 即 content+padding网页可见区域高： document.body.clientHeight网页可见区域宽： document.body.offsetWidth (包括边线的宽) content+padding+border网页可见区域高： document.body.offsetHeight (包括边线的高)网页正文全文宽： document.body.scrollWidth网页正文全文高： document.body.scrollHeight网页被卷去的高： document.body.scrollTop 顶部滚出内容长度网页被卷去的左： document.body.scrollLeft网页正文部分上： window.screenTop网页正文部分左： window.screenLeft屏幕分辨率的高： window.screen.height屏幕分辨率的宽： window.screen.width屏幕可用工作区高度： window.screen.availHeight屏幕可用工作区宽度： window.screen.availWidth在IE中：document.body.clientWidth ==&gt; BODY对象宽度document.body.clientHeight ==&gt; BODY对象高度document.documentElement.clientWidth ==&gt; 可见区域宽度document.documentElement.clientHeight ==&gt; 可见区域高度document.documentElement.scrollTop =&gt;窗口滚动条滚动高度在FireFox中：document.body.clientWidth ==&gt; BODY对象宽度document.body.clientHeight ==&gt; BODY对象高度document.documentElement.clientWidth ==&gt; 可见区域宽度document.documentElement.clientHeight ==&gt; 可见区域高度document.documentElement.scrollTop =&gt;窗口滚动条滚动高度在chrome中：document.body.clientWidth ==&gt; BODY对象宽度document.body.clientHeight ==&gt; BODY对象高度document.documentElement.clientWidth ==&gt; 可见区域宽度document.documentElement.clientHeight ==&gt; 可见区域高度document.body.scrollTop =&gt;窗口滚动条滚动高度在Opera中：document.body.clientWidth ==&gt; 可见区域宽度document.body.clientHeight ==&gt; 可见区域高度document.documentElement.clientWidth ==&gt; 页面对象宽度（即BODY对象宽度加上Margin宽）document.documentElement.clientHeight ==&gt; 页面对象高度（即BODY对象高度加上Margin高滚动到顶部 window.scrollTo(0,0)滚动到尾部 window.scrollTo(0,document.body.clientHeight)","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"ES6相关","slug":"ES6相关","date":"2021-05-06T04:16:12.000Z","updated":"2023-02-14T14:50:24.388Z","comments":true,"path":"2021/05/06/ES6相关/","link":"","permalink":"http://example.com/2021/05/06/ES6%E7%9B%B8%E5%85%B3/","excerpt":"","text":"ES6 ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。 因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015(简称ES2015）。虽然浏览器在不断更新，但并不是所有用户的电脑浏览器都支持ES6，所以在使用的过程中建议还是转成es5，保证代码的可执行性。至于转换的方式大家可以用Babel或者Traceur。 1.let和constES6以前没有块级作用域，只有全局作用域和函数作用域。而let的出现就是为了打破局面，let是块级作用域。const是代表常量，必须在定义的时候初始化，不可改变。 1234561 &#123;2 var a=5;3 let b=10;4 &#125;5 console.log(a);//56 console.log(b);//error 也就是说，var声明的变量由于不存在块级作用域所以可以在全局环境中调用，而let声明的变量由于存在块级作用域所以不能在全局环境中调用。 2.字符串拼接​ es6使用 包裹字符串，即使断开，也可以用这个符号包裹起来合并成一个字符串。 123456789101112 1 //传统字符串拼接 2 var s1 = &#x27;生物膜系统组装又拆分，变幻莫测；&#x27;; 3 var s2 = &#x27;你的好多细胞在分裂，&#x27;; 4 var str = &#x27;孩子们：请听我说！&#x27;+s2+&#x27;有丝，减数，哪管白天和黑夜。&#x27;+ 5 &#x27;染色体，细胞核时隐时现，&#x27;+s1+&#x27;核糖体在mRNA上穿梭忙碌，&#x27;+&#x27;几千种酶各司其职，将活化能狠狠打折。&#x27;; 6 console.log(str); 7 8 // 字符模板的写法 9 var s1 = &#x27;染色体，细胞核时隐时现，&#x27;;10 var s2 = &#x27;你的好多细胞在分裂，&#x27;;11 var str = `孩子们：请听我说！$&#123;s2&#125;有丝，减数，哪管白天和黑夜。$&#123;s1&#125;生物膜系统组装又拆分，变幻莫测；核糖体在mRNA上穿梭忙碌，几千种酶各司其职，将活化能狠狠打折。`;12 console.log(str); 3.解构赋值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591 // 以前我们给变量赋值，只能直接指定值 2 var a = 1; 3 var b = 2; 4 var c = 3; 5 console.log(a,b,c); // 1 2 3 6 7 // 现在用解构赋值的写法就变得简单了，只要模式匹配上了就行了，如下 8 // 注意数组是有顺序的 9 var [a,b,c] = [11,22,33];10 console.log(a,b,c); // 11 22 3311 12 var [b,a,c] = [11,22,33];13 console.log(a,b,c); // 22 11 3314 15 // 当然解构赋值还有嵌套比较复杂的写法，如下16 let [foo,[[bar],[baz]]] = [111,[[222],[333]]];17 console.log(foo,bar,baz); // 111 222 33318 19 let [head,...foot] = [1,2,3,4];20 console.log(head,foot); // 1 [2,3,4]21 22 // 如果解构不成功，变量的值就等于undefined，如下23 var [bar3,foo3] = [1000];24 console.log(bar3,foo3); // 1000 undefined25 26 // 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功27 let [x,y] = [10000,20000,30000];28 console.log(x,y); // 10000 2000029 30 // 默认值可以引用解构赋值的其他变量，但该变量必须已经声明31 let [a=1,b=a] = [2,3];32 console.log(a,b); // 2 333 34 // 对象的解构也可以指定默认值35 var &#123;x,y=5&#125; = &#123;x:1&#125;;36 console.log(x,y); // 1 537 38 //对象的解构赋值解构不仅可以用于数组，还可以用于对象(json)39 //对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；40 //而对象的属性没有次序，变量必须与属性同名，才能取到正确的值41 var &#123;a,b&#125; = &#123;a:&#x27;apple&#x27;,b:&#x27;banana&#x27;&#125;;42 console.log(a,b); // apple banana43 var &#123;b,a&#125; = &#123;a:&#x27;apple&#x27;,b:&#x27;banana&#x27;&#125;;44 console.log(a,b); // apple banana45 46 // 如果变量名与属性名不一致，必须写成下面这样47 let obj = &#123;first:&#x27;hello&#x27;,last:&#x27;world&#x27;&#125;;48 // first ---&gt; f，那么此时f就是first，而不是undefined了,有点类似别名的概念49 let &#123;first:f,last&#125; = obj;50 console.log(f,last); // hello world51 52 //1.也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。 真正被赋值的是后者，而不是前者53 //2.v是匹配的模式，n才是变量。真正被赋值的是变量n，而不是模式v。 54 //注意，采用这种写法时，变量的声明和赋值是一体的55 // v ---&gt; n，那么此时n就是vue，而不是undefined了56 var &#123;v:n&#125; = &#123;v:&#x27;vue&#x27;,r:&#x27;react&#x27;&#125;;57 console.log(n); // vue58 console.log(v); // Uncaught ReferenceError: v is not defined59 console.log(r); // Uncaught ReferenceError: r is not defined 4.复制数组123456789101112131415161718192021222324252627282930313233343536373839 // 数组的浅拷贝，引用之间的拷贝，没有实现数组的真正复制 2 var arr1 = [1, 2, 3]; 3 var arr2 = arr1; 4 arr2.push(4); 5 console.log(arr1, arr2); //[1, 2, 3, 4] [1, 2, 3, 4] 6 7 // 复制数组深拷贝，传统做法 8 var arr1 = [1,2,3]; 9 var arr2 = [];10 //通过for循环遍历之后将arr1数组的每一项赋值给arr2数组的每一项， 就实现了数组的深拷贝，这时候我再去操作arr2的数组的时候，arr1就不会受影响了11 for(var i=0;i&lt;arr1.length;i++)&#123;12 arr2[i] = arr1[i];13 &#125;14 // 数组尾部添加15 arr2.push(4);16 console.log(arr1,arr2);17 18 // ES6实现的数组的深拷贝方法119 var arr1 = [1,2,3];20 var arr2 = Array.from(arr1);21 // 数组尾部添加22 arr2.push(100);23 console.log(arr1,arr2); // [1, 2, 3] [1, 2, 3, 100]24 25 // ES6实现的数组的深拷贝方法226 var arr1 = [1,2,3];27 // 超引用拷贝数组28 var arr2 = [...arr1];29 // 数组尾部添加30 arr2.push(1000);31 console.log(arr1,arr2); // [1, 2, 3] [1, 2, 3, 1000]32 33 function show(...args)&#123;34 // 此时这个形式参数就是一个数组，我们可以直接push东西进来，如下35 args.push(5);36 console.log(args);37 &#125;38 // 调用39 show(1,2,3,4); // [1, 2, 3, 4, 5] 5.增加了map对象。倾向于后台12345678910111213141516171819202122232425262728293031323334353637383940411 var map = new Map(); 2 // 设置 3 // map.set(name,value); 4 map.set(&#x27;a&#x27;,&#x27;apple&#x27;); 5 map.set(&#x27;b&#x27;,&#x27;banana&#x27;); 6 // 获取 7 // map.get(name); 8 console.log(map.get(&#x27;a&#x27;) + &#x27; &#x27; + map.get(&#x27;b&#x27;)); 9 // 删除之前map对象10 console.log(map);11 // 删除12 // map.delete(name);13 map.delete(&#x27;a&#x27;);14 // 删除之后map对象15 console.log(map);16 17 // 注意for..in是不能循环map对象的，不报错也无任何反应，所以下一代码无任何输出，稍微注意下18 for(var name in map)&#123; 19 console.log(name);20 &#125;21 22 // 实体 map对象的循环输出23 for(var name of map)&#123;24 //循环出来的结果就是:a,apple b,banana 循环key,value25 console.log(name);26 &#125;27 28 //循环出来的结果就是: a,apple b,banana 循环key,value29 for(var [key,value] of map.entries())&#123;30 console.log(key,value);31 &#125;32 33 //只循环key34 for(var key of map.keys())&#123;35 console.log(key);36 &#125;37 38 //只循环value39 for(var val of map.values())&#123;40 console.log(val);41 &#125; 6.for-of循环123456789101112131415161718192021222324252627282930313233343536373839404142431 //for of一个arr对象 2 var arr = [&#x27;红楼梦&#x27;,&#x27;西游记&#x27;,&#x27;三国演义&#x27;,&#x27;水浒传&#x27;,&#x27;火影&#x27;]; 3 //只循环key 0 1 2 3 4 输出key值，也就是下标索引 4 for(var key of arr.keys())&#123; 5 console.log(key); 6 &#125; 7 //只循环value，注意数组是没有.values() 直接 var value of arr ,输出 红楼梦，西游记，三国演义，水浒传，火影 8 for(var value of arr)&#123; 9 console.log(value);10 &#125;11 //循环key,value12 for(var [key,value] of arr.entries())&#123;13 console.log(key,value);14 &#125;15 16 //for in循环与for of循环的区别17 var arr = [&#x27;apple&#x27;,&#x27;banana&#x27;,&#x27;orange&#x27;,&#x27;pear&#x27;];18 for(var i in arr)&#123;19 // i打印出来的就是arr数组对应的索引20 // 0 1 2 321 console.log(i);22 &#125;23 for(var i of arr)&#123;24 // i值打印出来的就是我们想要的数组具体的值25 // apple banana orange pear26 console.log(i);27 &#125;28 29 //for of不能循环json30 var json = &#123;&#x27;a&#x27;:&#x27;apple&#x27;,&#x27;b&#x27;:&#x27;banana&#x27;,&#x27;c&#x27;:&#x27;orange&#x27;,&#x27;d&#x27;:&#x27;pear&#x27;&#125;;31 for(var name in json)&#123;32 // a b c d33 console.log(name);34 // apple35 console.log(json.a);36 // pear37 console.log(json[&#x27;d&#x27;]);38 &#125;39 // 注意for..of可以循环arr，但是不可以循环json,会报错，特别注意下40 for(var name of json)&#123;41 Uncaught TypeError: undefined is not a function42 console.log(json);43 &#125; 7.箭头函数箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数，不能使用new。 箭头函数的写法 function(){ } 变成 ()&#x3D;&gt;{ } 1231 var a = ()=&gt;&#123;2 return 1;3 &#125; 等价于 1231 function a()&#123;2 return 1;3 &#125; 如果函数体只有一条语句，可以这样写： 121 var fun = ()=&gt;Math.random()*102 console.log(fun()); 这样子调用这个箭头函数就会直接返回这条语句的值 头函数不绑定arguments，取而代之用rest参数…解决 1234567891011121314 1 function A(a)&#123; 2 console.log(arguments); //[object Arguments] [1, 2, 3] 3 &#125; 4 5 var B = (b)=&gt;&#123; 6 console.log(arguments); //错误：ReferenceError: arguments is not defined 7 &#125; 8 9 var C = (...c)=&gt;&#123; //...c即为rest参数10 console.log(c); //[3, 1, 2]11 &#125;12 A(1,2,3);13 B(2,1,3);14 C(3,1,2); 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值 12345678910111213 1 var obj = &#123; 2 a: 10, 3 b: function()&#123; 4 console.log(this.a); //输出10 5 &#125;, 6 c: function() &#123; 7 return ()=&gt;&#123; 8 console.log(this.a); //输出10，捕获了上面obj的this作为自己的this 9 &#125;10 &#125;11 &#125;12 obj.b(); 13 obj.c()(); 所谓箭头函数的 this 捕获的是所在的上下文，比如下面这个例子：b是一个箭头函数，然后它的 this是指向window，这是为什么呢，因为箭头函数捕获的是obj&#123;&#125;这个对象的环境，然后这个环境的this指向的是window，就相当于上一条的例子：在c方法里面return的那个箭头函数捕获的是c:function()&#123;&#125;这个环境的this，而这个环境的this是obj 12345678910111213 1 var obj = &#123; 2 a: 10, 3 b: () =&gt; &#123; 4 console.log(this.a); //undefined 5 console.log(this); //window 6 &#125;, 7 c: function() &#123; 8 console.log(this.a); //10 9 console.log(this); //obj&#123;...&#125;10 &#125;11 &#125;12 obj.b(); 13 obj.c(); 对于函数的this指向问题： 箭头函数的this永远指向其上下文的 this，任何方法都改变不了其指向，如call(), bind(), apply() 普通函数的this指向调用它的那个对象 8.对象的简洁语法123456789101112131415161718192021222324252627282930311 //传统对象_单体模式写法 key-value模式 2 var person = &#123; 3 name:&#x27;krry&#x27;, 4 age:21, 5 showName:function()&#123; 6 return this.name; 7 &#125;, 8 showAge:function()&#123; 9 return this.age;10 &#125;11 &#125;;12 // 调用13 console.log(person.showName()); // krry14 console.log(person.showAge()); // 2115 16 //ES6_单体模式写法 不需要写key17 var name = &#x27;krry&#x27;;18 var age = 21;19 var person = &#123;20 name,21 age,22 showName()&#123;23 return this.name;24 &#125;,25 showAge()&#123;26 return this.age;27 &#125;28 &#125;;29 // 调用30 console.log(person.showName()); // krry31 console.log(person.showAge()); // 21 9.类和继承1.传统面向对象的写法： 123456789101112131415161 function Person(name,age)&#123; // 类、构造函数 2 this.name = name; 3 this.age = age; 4 &#125; 5 Person.prototype.showName = function()&#123; 6 return this.name; 7 &#125;; 8 Person.prototype.showAge = function()&#123; 9 return this.age;10 &#125;;11 var p1 = new Person(&#x27;allen&#x27;,28);12 var p2 = new Person(&#x27;xiaoxiaoyou&#x27;,101);13 console.log(p1.showName()); // allen14 console.log(p2.showAge()); // 10115 console.log(p1.showName == p2.showName); //true 注意不是调用方法，没有括号，所以才true16 console.log(p1.constructor == Person); // true 构造方法相等 2.ES6面向对象写法： 12345678910111213141516171819201 class Person&#123; 2 // 构造器 3 constructor(name,age)&#123; 4 this.name = name; 5 this.age = age; 6 &#125; 7 showName()&#123; 8 return this.name; 9 &#125;10 showAge()&#123;11 return this.age;12 &#125;13 &#125;14 var p1 = new Person(&#x27;aaa&#x27;,18);15 var p2 = new Person(&#x27;bbb&#x27;,20);16 console.log(p1.name); // aaa17 console.log(p1.showName()); // aaa18 console.log(p2.showAge()); // 2019 console.log(p1.showAge == p2.showAge); // true20 console.log(p1.constructor == Person); // true 3.面向对象给class赋值默认值 12345678910111213141516171 class Person&#123; 2 // 构造器 3 constructor(name=&#x27;default&#x27;,age=0)&#123; 4 this.name = name; 5 this.age = age; 6 &#125; 7 showName()&#123; 8 return this.name; 9 &#125;10 showAge()&#123;11 return this.age;12 &#125;13 &#125;14 15 var p1 = new Person();16 console.log(p1.name); // 构造器里面给的默认值 default17 console.log(p1.age); // 构造器里面给的默认值 0 4.传统写法原型继承extends 1234567891011121314151617181920211 //传统写法原型继承 2 function Person(name,age)&#123; // 类、构造函数 3 this.name = name; 4 this.age = age; 5 &#125; 6 Person.prototype.showName = function()&#123; 7 return this.name; 8 &#125;; 9 Person.prototype.showAge = function()&#123;10 return this.age;11 &#125;;12 // 工人类13 function Worker(name,age)&#123;14 // 属性继承过来15 Person.apply(this,arguments);16 &#125;17 // 原型继承18 Worker.prototype = new Person();19 var p1 = new Person(&#x27;allen&#x27;,28);20 var w1 = new Person(&#x27;worker&#x27;,1000);21 console.log(w1.showName()); // 确实继承过来了 result：worker 5.ES6中面向对象实现类继承 123456789101112131415161718192021222324252627281 class Person&#123; 2 // 构造器 3 constructor(name,age)&#123; 4 this.name = name; 5 this.age = age; 6 &#125; 7 showName()&#123; 8 return this.name; 9 &#125;10 showAge()&#123;11 return this.age;12 &#125;13 &#125;14 class Worker extends Person&#123;15 constructor(name,age,job=&#x27;啦啦啦&#x27;)&#123;16 // 继承超父类的属性17 super(name,age);18 this.job = job;19 &#125;20 showJob()&#123;21 return this.job;22 &#125;23 &#125;24 var p1 = new Person(&#x27;aaa&#x27;,18);25 var w1 = new Person(&#x27;www&#x27;,36);26 var w2 = new Worker(&#x27;wwwwwwww&#x27;,90);27 console.log(w1.showName()); // www28 console.log(w2.showJob()); // 默认给的值 ‘啦啦啦’ 10.模块化import 导入模块、export 导出模块 可以直接在任何变量或者函数前面加上一个 export 关键字，就可以将它导出。 在一个文件中： 12345671 export const sqrt = Math.sqrt;2 export function square(x) &#123;3 return x * x;4 &#125;5 export function diag(x, y) &#123;6 return sqrt(square(x) + square(y));7 &#125; 然后在另一个文件中这样引用： 1231 import &#123; square, diag &#125; from &#x27;lib&#x27;;2 console.log(square(11)); // 1213 console.log(diag(4, 3)); 总结： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081 //mod.js 2 // 第一种模块导出的书写方式(一个个的导出) 3 // 导出普通值 4 export let a = 12; 5 export let b = 5; 6 // 导出json 7 export let json = &#123; 8 a, 9 b 10 &#125;; 11 // 导出函数 12 export let show = function()&#123; 13 return &#x27;welcome&#x27;; 14 &#125;; 15 // 导出类 16 export class Person&#123; 17 constructor()&#123; 18 this.name = &#x27;jam&#x27;; 19 &#125; 20 showName()&#123; 21 return this.name; 22 &#125; 23 &#125; 24 25 //index.js 26 //导出模块如果用default了，引入的时候直接用，若没有用default，引入的时候可以用&#123;&#125;的形式 27 // 导入模块的方式 28 import &#123; 29 a, 30 b, 31 json, 32 show, 33 Person 34 &#125; from &#x27;./mod.js&#x27;; 35 console.log(a); // 12 36 console.log(b); // 5 37 console.log(json.a); // 12 38 console.log(json.b); // 5 39 console.log(show()); // welcome 40 console.log(new Person().showName()); // jam 41 42 //mod1.js 43 // 第二种模块导出的书写方式 44 let a = 12; 45 let b = 5; 46 let c = 10; 47 export &#123; 48 a, 49 b, 50 c as cc // as是别名，使用的时候只能用别名，特别注意下 51 &#125;; 52 53 //index1.js 54 // 导入模块的方式 55 import &#123; 56 a, 57 b, 58 cc // cc是导出的，as别名 59 &#125; from &#x27;./mod1.js&#x27;; 60 console.log(a); // 12 61 console.log(b); // 5 62 console.log(cc); // 10 63 64 //mod2.js 65 // 第三种模块导出的书写方式 ---&gt; default 66 // default方式的优点，import无需知道变量名，就可以直接使用，如下 67 // 每个模块只允许一个默认出口 68 var name = &#x27;jam&#x27;; 69 var age = &#x27;28&#x27;; 70 export default &#123; 71 name, 72 age, 73 default()&#123; 74 console.log(&#x27;welcome to es6 module of default...&#x27;); 75 &#125;, 76 getName()&#123; 77 return &#x27;bb&#x27;; 78 &#125;, 79 getAge()&#123; 80 return 2; 81 &#125; 82 &#125;; 83 84 //index2.js 85 // 导入模块的方式 86 import mainAttr from &#x27;./mod2.js&#x27;; 87 var str = &#x27; &#x27;; 88 // 直接调用 89 console.log(`我的英文名是:$&#123;mainAttr.name&#125;我的年龄是$&#123;mainAttr.age&#125;`); 90 mainAttr.default(); // welcome to es6 module of default... 91 console.log(mainAttr.getName()); // bb 92 console.log(mainAttr.getAge()); // 2 93 94 //mod3.js 95 var name = &#x27;jam&#x27;; 96 var age = &#x27;28&#x27;; 97 export function getName()&#123; 98 return name; 99 &#125;;100 export function getAge()&#123;101 return age;102 &#125;;103 104 //index3.js105 // 导入模块的方式106 import * as fn from &#x27;./mod3.js&#x27;;107 // 直接调用108 console.log(fn.getName()); // jam 11.Promise在promise之前代码过多的回调或者嵌套，可读性差、耦合度高、扩展性低。通过Promise机制，扁平化的代码机构，大大提高了代码可读性；用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。 就是用同步的方式去写异步代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283841 //Promise对象 ---&gt; 用来传递异步操作过来的数据的 2 //Pending(等待、处理中) ---&gt; Resolve(完成，fullFilled) ---&gt; Reject(拒绝，失败) 3 //这里只是定义，还没开始执行 4 var p1 = new Promise(function(resolve,reject)&#123; 5 resolve(1); // 成功了，返回一个promise对象1 6 // reject(2); // 失败了 7 &#125;); 8 9 // 接收成功和失败的数据，通过then来传递10 // then也是返回一个promise对象，会继续往下传递数据,传递给下一个then11 p1.then(function(value)&#123;12 // resolve13 console.log(value); //执行打印114 return value + 1; // 115 alert(`成功了：$&#123;value&#125;`);16 &#125;,function(value)&#123;17 // reject18 alert(`失败了：$&#123;value&#125;`);19 &#125;).then(function(value)&#123;20 console.log(value); // 221 &#125;);22 23 //catch捕获异常错误24 var p1 = new Promise(function(resolve,reject)&#123;25 resolve(&#x27;成功了&#x27;); //返回一个promise对象“成功了”26 &#125;);27 //then也是返回一个promise对象，会继续往下传递数据28 p1.then(function(value)&#123;29 console.log(value); //打印“成功了”30 // throw是用来抛错误的31 throw &#x27;发生了点小意外&#x27;;32 &#125;).catch(function(e)&#123;33 // catch用来捕获这个错误的 ---&gt; 追踪34 console.log(e);35 &#125;);36 37 //all ---&gt; 全部，用于将多个promise对象，组合，包装成38 //Promise.all([p1,p2,p3,...]); 所有的promise对象，都正确，才走成功39 //否则，只要有一个错误，就走失败40 var p1 = Promise.resolve(1);41 var p2 = Promise.reject(0);42 Promise.all([true,p1,p2]).then(function(obj)&#123;43 console.log(`成功了：$&#123;obj&#125;`);44 &#125;,function(obj)&#123;45 console.log(`失败了：$&#123;obj&#125;`);46 &#125;);47 48 // race ---&gt; 返回的也是一个promise对象49 //最先执行的的promise结果，哪个最快我用哪个，所以下面打印的是one50 var p1 = new Promise(function(resolve,reject)&#123;51 setTimeout(resolve,50,&#x27;one&#x27;);52 &#125;);53 var p2 = new Promise(function(resolve,reject)&#123;54 setTimeout(resolve,100,&#x27;two&#x27;);55 &#125;);56 Promise.race([p1,p2]).then(function(val)&#123;57 console.log(val);58 &#125;);59 60 //resolve ---&gt; 生成一个成功的promise对象61 //语法规则：Promise.resolve(val); // 普通值62 // Promise.resolve(arr); // 数组之类63 //Promise.resolve(promise); // 传递另一个promise对象64 //传递普通值65 Promise.resolve(&#x27;success&#x27;).then(function(val)&#123;66 // 注意resolve，走得是这里67 console.log(val); // success68 &#125;,function(err)&#123;69 console.log(&quot;err:&quot;+ err);70 &#125;);71 //传递数组72 Promise.resolve([1,2,3]).then(function(val)&#123;73 // 注意resolve，走得是这里74 console.log(val); // [1,2,3]75 &#125;,function(err)&#123;76 console.log(err);77 &#125;);78 //传递一个promise对象79 var p1 = Promise.resolve(520);80 var p2 = Promise.resolve(p1);81 p2.then(function(val)&#123;82 //从p1那边传递过来的83 console.log(val); // 52084 &#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"Java IO流","slug":"Java IO流","date":"2021-01-01T04:16:12.000Z","updated":"2023-02-14T16:27:11.619Z","comments":true,"path":"2021/01/01/Java IO流/","link":"","permalink":"http://example.com/2021/01/01/Java%20IO%E6%B5%81/","excerpt":"","text":"5.IO流IO流常用基类字节流的抽象基类： InputStream ，OutputStream。 字符流的抽象基类： Reader ， Writer。 File类Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。 构造方法： File(String pathname)：通过路径名创建一个新 File 实例（对象）。 File(File parent, String child)：根据父目录路径File实例和子目录或文件路径创建一个新 File 实例。 File(String parent, String child) ：根据父目录路径和子目录或文件路径创建一个新 File 实例。 路径不区分大小写 反斜杠是转义，两个反斜杠代表一个普通反斜杠 public File（String pathname） 123456参数：String pathname：字符串的路径名称路径可以使以文件结尾，也可以是以文件夹结尾路径可以是相对路径，也可以使绝对路径路径可以是存在的，也可以使不存在的创建File对象，只是把字符串路径封装在File对象，不考虑路径的真假情况 File类常用方法获取功能的方法1234567public String getName()：返回由此抽象路径名表示的文件或目录的名称。public String getPath()：将此抽象路径名转换为一个路径名字符串。public String getAbsolutePath()：返回抽象路径名的绝对路径名字符串。public long length()：返回由此抽象路径名表示的文件的长度。 判断功能的方法123public boolean exists()：测试此抽象路径名表示的文件或目录是否存在。public boolean isDirectory()：测试此抽象路径名表示的文件是否是一个目录。public boolean isFile()：测试此抽象路径名表示的文件是否是一个标准文件。 创建删除功能的方法123456public boolean createNewFile() throws IOException：当且仅当不存在具有此抽象路径名指定的名称的文件时，原子地创建由此抽象路径名指定的一个新的空文件。 1.只能创建文件，不能创建文件夹2.创建文件的路径必须存在，否则抛出异常public boolean delete()： 删除此抽象路径名表示的文件或目录。 删除该路径结尾的路径或者文件 直接删除，不走回收站public boolean mkdir()：创建此抽象路径名指定的目录。 注意是创建目录目录目录 创建单级文件夹public boolean mkdirs()：创建此抽象路径名指定的目录，包括创建必需但不存在的父目录。 创建单或者多级文件夹 目录的遍历12345public String[] list()：返回一个String数组，表示该File目录中的所有子文件或目录 File对象不能含有文件名，只能是文件夹名错误示范File file3 = new File(&quot;D:\\\\AAAA\\\\bbbb.txt&quot;); file3.list();显示null正确示范：File dir = new File(&quot;D:\\\\bbbb\\\\cccc&quot;); public String[] list(FilenameFilter filter)：返回File数组，表示该File目录中的所有子文件或目录 OutputStream流OutputStream是抽象类 java.io.OutputStream：字节输出流此抽象类是表示输出字节流的所有类的超类 定义了一些子类共性的成员方法：-public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。-public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。-public void write(byte[] b ) ：将b.length字节从指定的字节数组写入此输出流。-public void write(byte[] b,int off,int len) ：从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。-public abstract void write(int b) ：将指定的字节输出流。 构造方法：FileOutputStream(String name)创建一个向具有指定名称的文件中写入数据的输出文件流。FileOutputStream(File file)创建一个向指定File对象表示的文件中写入数据的文件输出流。参数：写入数据的目的String name:目的地是一个文件的路径File file:目的地是一个文件 构造方法的作用：1.创建一个FileOutputStream对象2.会根据构造方法中传递的文件&#x2F;文件路径，创建一个空的文件3.会把FileOutputStream对象指向创建好的文件 写入数据的原理（内存–&gt;硬盘）java程序–&gt;JVM(java虚拟机）–&gt;OS（操作系统）–&gt;OS调用写数据的方法–&gt;把数据写入到硬盘文件中 字节输出流的使用步骤（重点）1.创建一个FileOutputStream对象，构造方法中传递写入数据的目的地2.调用FileOutputStream对象中的方法write,把数据写入到文件中3.释放资源（流使用会占用一定的内存，使用完毕要把内存清空，提高程序的效率） InputStream流java.io.InputStream：字节输入流此抽象类是表示字节输入流的所有类的超类 定义了所有子类共性的方法 12345int read()从输入流中读取数据的下一个字节。int read(byte[] b)从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。void close() 关闭此输入流并释放与该流关联的所有系统资源。 FileInputStream:文件字节输入流java.io.FileInputStream extends InputStream 作用：把硬盘文件中的数据，读取到内存中使用 构造方法： 12345FileInputStream(String name)FileInputStream(File file)参数：读取文件的数据源String name:文件的路径File file：文件 构造方法的作用： 121.会创建一个FileInputStream对象2.会把FileInputStream对象指定构造方法中要读取的文件 读取数据的原理（硬盘–&gt;内存）java程序–&gt;JVM–&gt;OS–&gt;OS读取数据的方法–&gt;读取文件 字节输入流的使用步骤（重点） 1231.创建FileInputStream对象，构造方法中绑定要读取的数据源2.使用FileInputStream对象中的方法read，读取文件3.释放资源 字节输入流一次读取多个字节的方法 123456789int read(byte[] b)从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。明确两件事情：1.方法的参数byte[]的作用？起到缓冲作用，存储每次读取到的多个字节数组的长度一般定义为1024（1kb)或者1024的整数倍2.方法的返回值int是什么？每次读取的有效字节个数 String类的构造方法 123String(byte[] bytes)：把字节数组转换为字符串String(byte[] bytes,int offset,int length)把字节数组的一部分转换为字符串.offset:数组的开始索引 length:转换的字节个数 FileOutputStream流OutputStream的子类FileOutputStream 构造方法： 123FileOutputStream(File file)FileOutputStream(String name) 推荐第二种构造方法： 1FileOutputStream outputStream = new FileOutputStream(&quot;a.txt&quot;); 创建字节输出流对象了做了几件事情： 123A:调用系统功能去创建文件B:创建outputStream对象C:把foutputStream对象指向这个文件 通过字节输出流写出数据到文本 123public void write(int b)public void write(byte[] b)：将b.length字节从指定的字节数组写入此输出流。public void write(byte[] b,int off,int len)：从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。 从方法中可看出，只能通过字节写出 123456outputStream.write(&quot;hello&quot;.getBytes()); 文本中出现hellooutputStream.write(96) //文本中出现 abyte[] bys=&#123;97,98,99,100,101&#125;;outputStream.write(bys,1,3); 文本中出现bcd 如此写出，文本中数据不会换行，不会追加，每次写出都是覆盖原来。 追加： 12345678910111213FileOutputStream outputStream = new FileOutputStream(&quot;a.txt&quot;,true);//第二个参数true设置为可追加FileOutputStream(String name,booleanappend)：创建一个向具有指定name的文件中写入数据的输出文件流。FileOutputStream（File file,booleanappend)：创建一个向指定File对象表示的文件中写入数据的文件输出流。参数：String name,File file:写入数据的目的地boolean append:追加写开关true:创建对象不会覆盖源文件，继续在文件的末尾追加写数据false:创建一个新文件，覆盖源文件 换行 \\n\\r ： 1234for (int i = 0; i &lt;5 ; i++) &#123; outputStream.write(&quot;hello&quot;.getBytes()); outputStream.write(&quot;\\n\\r&quot;.getBytes()); &#125; 注：用完流一定要记得关闭。 1outputStream.close(); FileInputStream流FileInputStream的构造方法： 12FileInputStream(File file)FileInputStream(String name) 推荐第二种构造方法： 1FileInputStream inputStream = new FileInputStream(&quot;a.txt&quot;); 把刚才写的数据现在读取到控制台： 12public int read()public int read(byte[] b) 第一个read是读一个字节，第二个read是读一个字节数组。 12345//读一个字节int by = 0;while ((by=inputStream.read())!=-1)&#123; System.out.println((char)by);&#125; 读到没数据了就返回-1，这个用来判断是否读完。 1234567//读一个字节数组，一般是1024大小int len = 0 ;byte[] bys = new byte[1024];while ((len = inputStream.read(bys)) != -1) &#123; System.out.println(new String(bys,0,len));&#125; 两个read的返回值略有不同，read()返回读取的字节，读到末尾返回-1，read(byte[] b)返回的是读到的字节个数，读到的字节放在了bytes字节数组里，读到末尾没数据了返回-1。 同样的用完了流，也要及时的关闭，以防占用内存。 1inputStream.close(); 字节流复制文件： 利用输入流读取一个文件里的字节，再利用输出流将读取到的字节写出到另一个文件中（不存在会自动创建） 12345678910111213141516171819202122232425262728package io2;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Arrays;/** * Create by stefan * Date on 2018-05-27 23:19 * Convertion over Configuration! */public class copy &#123; public static void main(String args[]) throws IOException &#123; FileInputStream inputStream = new FileInputStream(&quot;E:\\\\huge1.jpg&quot;); FileOutputStream outputStream = new FileOutputStream(&quot;E:\\\\古月.jpg&quot;); byte[] bytes = new byte[1024]; int len = 0; while ((len=inputStream.read(bytes)) != -1) &#123; outputStream.write(bytes,0,len); &#125; inputStream.close(); outputStream.close(); &#125;&#125; 注：复制文本、图片、mp3、视频等的方式一样。 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，这是加入了数组这样的缓冲区效果。 java本身在设计的时候，也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流。 1234字节缓冲输出流BufferedOutputStream字节缓冲输入流BufferedInputStream BufferedOutputStream123BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;a.txt&quot;,true));bos.write(&quot;hello world&quot;.getBytes());bos.close(); BufferedInputStream12345678BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.txt&quot;));byte[] bytes = new byte[1024];int len = 0;while ((len=bis.read(bytes)) != -1) &#123; System.out.println(new String(bytes,0,len));&#125;bis.close(); 注： 1234成员方法与字节流基本一样，字节缓冲流的作用就是提高输入输出的效率。构造方法可以指定缓冲区的大小，但是我们一般用不上，因为默认缓冲区大小就足够了。为什么不传递一个具体的文件或者文件路径，而是传递一个OutputStream对象呢?原因很简单，字节缓冲区流仅仅提供缓冲区，为高效而设计的。但是呢，真正的读写操作还得靠基本的流对象实现。 复制文件的升级： 12345678910BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;E:\\\\modern-java.pdf&quot;));BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;F:\\\\汤包\\\\慕课大巴\\\\modern-java.pdf&quot;));int len = 0;byte[] bytes =new byte[1024];while ((len=bis.read(bytes)) != -1) &#123; bos.write(bytes,0,len);&#125;bis.close();bos.close(); 字符流字符流 : 只能操作纯文本的内容 属于节点流纯文本示例: .txt .html ReaderReader 字符输入流 超类 不能实例化（抽象类）FileReader 文件字符输入流 Reader字符输入流的基本共性功能方法 123public void close();关闭此流并释放此流相关的任何资源public int read();从输入流读取一个字符 //读取一个后会自动标识，再次读就会读下一个字符public int read(char[] cbuf):从输入流中读取一些字符，并将它们存储到字符数组cbuf中。 FileReader类构造方法 12FileReader(File file):使用File对象的路径创建输入流FileReader(String fileName):使用字符串路径创建输入流 常用读取方法演示： 12345678910111213141516171819202122232425262728293031323334import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;​public class Test02 &#123; public static void main(String[] args) throws IOException &#123; //字符输入流的常用方法 FileReader fr = new FileReader(&quot;C:\\\\Users\\\\jin\\\\Desktop\\\\文件复制.java&quot;);// FileInputStream fr = new FileInputStream(&quot;C:\\\\Users\\\\jin\\\\Desktop\\\\文件复制.java&quot;);​ //read() :读取一个字符 //返回的是字符对应的数值 //如果读到了文件的末尾会返回-1 //int i; //while((i=fr.read()) != -1)&#123; // System.out.println((char)i); //&#125;​ //read(char[] chs): 读取一个字符数组的内容 //读取返回的是读取到的字符个数，如果读到了末尾会返回-1 char[] chs = new char[5]; int len; while((len=fr.read(chs)) != -1)&#123; System.out.println(new String(chs,0,len)); &#125;​​ //close() //关闭流资源 fr.close(); &#125;&#125; BufferedReader字符缓冲流 BufferedReader类从字符输入流中读取文本并缓冲字符，以便有效地读取字符，数组和行 字符缓冲输入流，具体如下： java.io.BufferedReader extends Reader 继承自父类的共性成员文件： 12345int read()读取单个字符并返回int read(char[] cbuf)一次读取多个字符，将字符读入数组void close()关闭该流并释放与之关联的所有资源 构造方法： 123456781.BufferedReader(Reader in)构建一个使用默认大小输入缓冲区的缓冲字符输入流2.BufferedReader(Reader in,int sz)创建一个使用指定大小输入缓冲区的缓冲字符输入流参数：Read in:字符输入流我们可以传递FileReader，缓冲流会给FileReader增加一个缓冲区，提高FileReader的读取效率。 特有成员方法： 123String readLine()读取一个文本行，读取一行数据行的终止符号：通过下列字符之一即可认为某行已终止：换行(‘\\n’)、(‘\\r’)或回车后直接跟着换行。 代码如下： 123456789101112131415161718192021222324252627public class Demo01BufferedReader &#123;public static void main(String args[]) throws IOException &#123;//1.创建字符缓冲输入流对象，构造方法中传递字节输出流BufferedReader br=new BufferedReader(new FileReader(&quot;D:\\\\programming\\\\Eclipse\\\\eclipse-workspace\\\\bbb\\\\src\\\\bbb\\\\a&quot;));/2.使用缓冲输入流对象中的方法read/readLine读取文本String line;while((line=br.readLine())!=null) &#123;//不知道文件中有多少行数据，用while循环System.out.println(line);&#125;//3.释放资源br.close();&#125;&#125; WriterWriter 字符输出流 超类 不能实例化FileWriter 文件字符输出流 字符流输出父类Writer 常用方法 123456close()：关闭流资源flush() ：刷新write(int c)：写出一个字符write(char[] cbuf)：写出一个字符数组的内容write(char[] b, int off, int len)：写出一个字符数组的一部分write(String str)：写出一个字符串 FileWriter类构造方法： 123456方法 说明FileWriter(File file)：用File对象所表示的路径创建输出流对象FileWriter(String fileName)：File字符串所表示的路径创建输出流对象FileWriter(File file,boolean b)：用File对象所表示的路径创建输出流对象,true表示续写FileWriter(String fileName,boolean b)：File字符串所表示的路径创建输出流对象,true表示续写 构造方法演示： 1234567891011121314151617181920212223242526272829303132import java.io.File;import java.io.FileWriter;import java.io.IOException;​public class Test03 &#123; public static void main(String[] args) throws IOException &#123; //字符输出流构造方法 /* 注意事项： 1.如果文件不存在,输出流会创建文件 2.如果文件已存在,输出流会覆盖文件 3.所有流只能操作文件,不能操作文件夹(拒绝访问。) 4.如果构造加了参数true 表示不清空文件 续写 */ //FileWriter(File file) //用File对象所表示的路径创建输出流对象 //FileWriter fw = new FileWriter(new File(&quot;day10\\\\123.txt&quot;));​​ //FileWriter(String fileName) //File字符串所表示的路径创建输出流对象 //FileWriter fw2 = new FileWriter(&quot;day10\\\\123.txt&quot;);​ //FileWriter(File file,boolean b) //用File对象所表示的路径创建输出流对象,true表示续写 //FileWriter fw = new FileWriter(new File(&quot;day10\\\\123.txt&quot;),true);​ //FileWriter(String fileName,boolean b) //File字符串所表示的路径创建输出流对象,true表示续写 FileWriter fw2 = new FileWriter(&quot;day10\\\\123.txt&quot;,true); &#125;&#125; 常用方法： 123456789101112131415161718192021222324252627282930313233import java.io.FileWriter;import java.io.IOException;​public class Test05 &#123; public static void main(String[] args) throws IOException &#123; //创建对象 FileWriter fw = new FileWriter(&quot;day10\\\\123.txt&quot;);​ //write(int c) //写出一个字符 fw.write(97); fw.write(&#x27;a&#x27;); fw.write(&#x27;我&#x27;);​ //write(char[] cbuf) //写出一个字符数组的内容 char[] chs = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;我&#x27;,&#x27;爱&#x27;,&#x27;你&#x27;&#125;; fw.write(chs);​ //write(char[] b, int off, int len) //写出一个字符数组的一部分 //输出“我爱你”这部分，3索引开始输出3个 fw.write(chs,3,3);​ //write(String str) //写出一个字符串 fw.write(&quot;石原里美&quot;); //关闭资源 fw.close(); &#125;&#125; 输出流换行符号： 123windows： \\r\\nlinux：/n mac: /r 关闭和刷新 123456关闭和刷新字符输出流底层有一个缓冲区，输出的字符会被先放在缓冲区。当调用刷新或者是缓冲区放满时才会真正的输出到文件中。close()方法自带刷新功能,只要最后记得关流，中间可以不做刷新。 BufferedWriterBufferedWriter:字符缓冲输出流 构造方法 12345BufferedWriter(Writer out) :默认缓冲区大小构造字符缓冲输出流对象BufferedWriter(Writer out,int size):指定缓冲区大小 常用方法 1234567891011public void write(int c) throws IOException写入单个字符。c - 指定要写入字符的 int。public void write(String str) throws IOException写入字符串。str - 要写入的字符串public void close() throws IOException关闭此流，但要先刷新它。 特有方法 12public void newLine() throws IOException写入一个行分隔符。 程序示例 12345678910111213141516public static void main(String[] args) throws Exception &#123; //创建一个字符缓冲输出流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;)) ; //写数据 bw.write(&quot;hello&quot;); bw.write(&quot;world&quot;); //刷新流 bw.flush(); //关闭资源 bw.close(); &#125; properties类 Properties 类位于 java.util.Properties ，以key&#x3D;value 的 键值对的形式进行存储值。 key值不能重复。 继承了Hashtable 类，以Map 的形式进行放置值， put(key,value) get(key) Properties是唯一个IO流相结合的集合，是双列集合。它的键跟值都是字符串 成员方法： 1234567void store(OutputStream streamOut, String description)：以适合使用 load(InputStream)方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。void load(InputStream streamIn) throws IOException：从输入流中读取属性列表（键和元素对）。Object setProperty(String key, String value)：调用 Hashtable 的方法 put。String getProperty(String key)： 用指定的键在此属性列表中搜索属性。String getProperty(String key, String defaultProperty)：用指定的键在属性列表中搜索属性。Enumeration propertyNames( )：按简单的面向行的格式从输入字符流中读取属性列表（键和元素对） 转换流InputStreamReader类InputStreamReader：是字节转换为字符的桥梁，它使指定的charset读取字节并将其解码为字符。（解码：把看不懂的字节变成可以看懂的字符） 继承自父类共性的成员方法： 12345int read()读取单个字符并返回int read(char[] cbuf)一次读取多个字符，将字符读入数组void close()关闭该流并释放与之关联的所有资源 构造方法： 12345678910111213141516InputStreamReader(InputStresam in)创建一个使用默认字符集的InputStreamReaderInputStreamReader(InputStresam in,String charsetName)创建使用指定字符集的InputStreamReader。参数：InputStresam in：字节输入流，用来读取文件中保存的字节String charsetName:指定的编码名称，不区分utf-8/UTF-8,gbk/GBK,……不指定默认使用UTF-8.使用步骤：1.创建InputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称2.使用InputStreamReader对象中的方法read读取文件3.释放资源 123456789101112131415161718192021222324252627282930313233343536373839注意事项：构造方法中指定的编码表名称要和文件相同，否则会发生乱码。代码如下：public class Demo03InputStreamReader &#123;public static void main(String args[]) throws IOException &#123;//读取默认格式为utf-8格式的文件，指定编码表名称InputStreamReader isr=new InputStreamReader(new FileInputStream(&quot;D:\\\\a.txt&quot;),&quot;utf-8&quot;);int len=0;while((len=isr.read())!=-1) &#123;System.out.println((char)len);&#125;isr.close();//读取格式为Unicode的文件，指定编码表UnicodeInputStreamReader i=new InputStreamReader(new FileInputStream(&quot;D:\\\\b.txt&quot;),&quot;Unicode&quot;);int lens=0;while((lens=i.read())!=-1) &#123;System.out.println((char)lens);&#125;i.close();&#125;&#125; OutputStreamWriter类转换流 java.io.OutputStreamReader ，是Writer的子类，是从字符流到字节流的桥梁。 它使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 继承父类的共性成员方法 该类继承 Writer 类，继承了父类的共性成员方法 1234567void write(int c) 写入单个字符。void write(char[] cbuf)写入字符数组。abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。void write(String str)写入字符串。void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。void flush()刷新该流的缓冲。void close() 关闭此流，但要先刷新它。 构造方法： 12345678OutputStreamWriter(OutputStream out)创建使用默认字符编码的 OutputStreamWriter。OutputStreamWriter(OutputStream out, String charsetName) 创建使用指定字符集的 OutputStreamWriter。参数： OutputStream out：字节输出流,可以用来写转换之后的字节到文件中 String charsetName：指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,...不指定默认使用UTF-8 使用步骤： 1234567① 创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称 ② 使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码) ③ 使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程) ④ 释放资源 代码示例： 12345678910111 public static void main(String[] args) throws IOException &#123; 2 //1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称 3 //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;E:\\\\utf_8.txt&quot;),&quot;utf-8&quot;); 4 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;E:\\\\utf_8.txt&quot;));//不指定默认使用UTF-8 5 //2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码) 6 osw.write(&quot;你好&quot;); 7 //3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程) 8 osw.flush(); 9 //4.释放资源10 osw.close();11 &#125; 序列化与反序列化一、基本概念 1、序列化和反序列化的定义： (1)Java序列化就是指把Java对象转换为字节序列的过程 Java反序列化就是指把字节序列恢复为Java对象的过程。 (2)序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。 反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。 总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息） 123452、json/xml的数据传递： 在数据传输(也可称为网络传输)前，先通过序列化工具类将Java对象序列化为json/xml文件。在数据传输(也可称为网络传输)后，再将json/xml文件反序列化为对应语言的对象 12345673、序列化优点： ①将对象转为字节流存储到硬盘上，当JVM停机的话，字节流还会在硬盘上默默等待，等待下一次JVM的启动，把序列化的对象，通过反序列化为原来的对象，并且序列化的二进制序列能够减少存储空间（永久性保存对象）。 ②序列化成字节流形式的对象可以进行网络传输(二进制形式)，方便了网络传输。 ③通过序列化可以在进程间传递对象。 Java实现序列化和反序列化的过程 1、实现序列化的必备要求： 只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） 2、JDK中序列化和反序列化的API： ①java.io.ObjectInputStream：对象输入流。 该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。 ②java.io.ObjectOutputStream：对象输出流。 该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。 3、实现序列化和反序列化的三种实现： 123456789101112131415①若Student类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化。 ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。 ObjcetInputStream采用默认的反序列化方式，对Student对象的非transient的实例变量进行反序列化。 ②若Student类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。 ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。 ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。 ③若Student类实现了Externalnalizable接口，且Student类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。 ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。 ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。 序列化和反序列化代码示例： 12345678910111213141516171819public class SerializableTest &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //序列化 FileOutputStream fos = new FileOutputStream(&quot;object.out&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); Student student1 = new Student(&quot;lihao&quot;, &quot;wjwlh&quot;, &quot;21&quot;); oos.writeObject(student1); oos.flush(); oos.close(); //反序列化 FileInputStream fis = new FileInputStream(&quot;object.out&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Student student2 = (Student) ois.readObject(); System.out.println(student2.getUserName()+ &quot; &quot; + student2.getPassword() + &quot; &quot; + student2.getYear()); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839public class Student implements Serializable&#123; private static final long serialVersionUID = -6060343040263809614L; private String userName; private String password; private String year; public String getUserName() &#123; return userName; &#125; public String getPassword() &#123; return password; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getYear() &#123; return year; &#125; public void setYear(String year) &#123; this.year = year; &#125; public Student(String userName, String password, String year) &#123; this.userName = userName; this.password = password; this.year = year; &#125; &#125; ObjectOutputStream流构造函数： 12345//为完全重新实现 ObjectOutputStream 的子类提供一种方法，让它不必分配仅由 ObjectOutputStream 的实现使用的私有数据。protected ObjectOutputStream();//创建写入指定 OutputStream 的 ObjectOutputStream。此构造方法将序列化流部分写入底层流；调用者可以通过立即刷新流，确保在读取头部时，用于接收 ObjectInputStreams 构造方法不会阻塞。public ObjectOutputStream(OutputStream out); 对象的序列化流 如果我们想要序列化一个对象，如我们自定义的User类的对象，那么这个对象必须实现Serializable接口。Serializable接口没有任何的抽象方法，实现这个接口仅仅是为了通知编译器已这个对象将要被序列化，所以此接口仅仅是一个表示接口。类似的用法还有Cloneable接口，实现这个接口也只是起到通知编译器的作用。 serialVersionUID在对象进行序列化或者反序列化操作的时候，要考虑JDK版本的问题，如果序列化的JDK版本和反序列化的JDK版本不统一则就可能造成异常，所以在序列化操作中引入了一个serialVersionUID的常量，可以通过此常量来验证版本的一致性，在进行反序列化时,JVM会将传过来的字节流中的serialVersionUID与本地相应实体的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就抛出不一致的异常。 static final long serivalVersionUID &#x3D; 手动给对象添加序列号 到底序列化了哪些东西呢？ 所有的对象拥有各自的属性值，但是所有的方法都是公共的，所以序列化对象的时候实际上序列化的就是属性。 ObjectInputStream流对象的反序列化流 构造函数： 123456//为完全重新实现 ObjectInputStream 的子类提供一种方式，让它不必分配仅由 ObjectInputStream 的实现使用的私有数据。protected ObjectInputStream();//创建从指定 InputStream 读取的 ObjectInputStream。从流读取序列化头部并予以验证。在对应的 ObjectOutputStream 写入并刷新头部之前，此构造方法将阻塞。public ObjectInputStream(InputStream in); 常用方法： 12//从 ObjectInputStream 读取对象。对象的类、类的签名和类及所有其超类型的非瞬态和非静态字段的值都将被读取。public final Object readObject(); 序列化的一般步骤可以分为5步： 1234567891.声明对象输出流2.声明文件输出流，并实例化3.用文件输出流对象实例化对象输出流4.调用对象输出流的writeObject函数保存对象5.关闭对象输出流 反序列化步骤： 1234567891.声明对象输入流2.声明文件输入流3.用文件输入流对象实例化对象输入流4.调用对象输入流的readObject函数读取对象，打印读取到的对象内容5.关闭对象输入流 transient关键字：*在序列化操作的时候，如果某个属性不希望被序列化下来，则可以直接使用transient 关键字声明。* 注意： static关键字：静态关键字 静态优先于非静态加载到内存中（静态优先于对象进入到内存中） 被static修饰的成员变量不能被序列化，序列化的都是对象。 打印流PrintStream：打印流 PrintStream的特点： 1.只负责数据的输出，不负责数据的读取 2.与其他输出流不同，PrintStream永远都不会抛出IOException异常 3.有特有的方法，print，println void print（可以输出任意类型的值） void println（可以输出任意类型的值并换行） 构造方法： 1234构造方法: PrintStream(File file):输出的目的地是一个文件 PrintStream(OutputStream out):输出的目的地是一个字节输出流 PrintStream(String fileName) :输出的目的地是一个文件路径 12345678910PrintStream extends OutputStream继承自父类的成员方法: - public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 - public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 - public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 - public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 - public abstract void write(int b) ：将指定的字节输出流。注意: 如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a 如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Java基础语法","slug":"Java基础语法","date":"2021-01-01T04:16:12.000Z","updated":"2023-02-14T16:27:21.467Z","comments":true,"path":"2021/01/01/Java基础语法/","link":"","permalink":"http://example.com/2021/01/01/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1.Java基础语法1.1数据类型1.1.1基本数据类型 数据类型 关键字 内存占用 取值范围 默认值 字节型 byte 1个字节 -128~127 0 短整型 short 2个字节 -32768-32767 0 整形 int 4个字节 -2,147,483,648-2,147,483,647 0 长整型 long 8个字节 -9,223,372,036,854,775,808（-2^63）-9,223,372,036,854,775,807（2^63 -1） 0 单精度浮点数 float 4个字节 -2^31 - 2^31-1 0.0 双精度浮点数 double 8个字节 -2^63 - 2^63-1 0.0 字符型 char 2个字节 0 - 2^16-1 \\u0000 布尔型 boolean 1个字节 true、false false 1.1.2引用数据类型除了上面的基本数据类型，其他的都是数据类型都是引用类型，如字符串、数组、类、接口、Lambda。 1.1.3变量、常量变量–&gt;变化的量（程序运行期，内容可以发生改变的量），可以用英文字母来表示变量，a、b、c、d等等 常量-&gt;不变的量，10、20、30 注意事项： 变量必须要有数据类型，且变量每次只保存一个值 变量赋值后才能使用 多个变量名不能重复 1.1.4数据类型的转换1.1.4.A小转大、大转小小转大可以能够自动转换 大转小需要强制转换且这个过程可能会出现数据溢出，即小数据类型放不下那么多，造成数据溢出。 大转小语法： 格式：范围小的类型 小范围变量名 &#x3D; （范围小的类型）原本范围大的数据类型 long —&gt; int 大转小 int num &#x3D; （int）100L； 1.1.5运算符 算数运算符 + 略 - 略 * 略 &#x2F; 除法运算符 % 取模运算符，两个数字相除取余数 ++ 自增运算符 – 自减运算符 +运算法常用用法 一、对于数值来说就是加法 二、对于字符char类型来说，在计算之前，char会被提升为int，然后再进行计算，char类型字符，和int类型数字，之间的对照关系表：ASCII、Unicode. 三、对于字符串String来说，加好代表字符串的链接 自增运算符++， 自减运算符–， 让一个变量增加一个数字1，或者ra减一个数字1。 用法：例如num++，++num，num–，–num。 单独使用：num++，++num没有区别。 混合使用： A.如果是前++，++num，那么变量立刻+1，然后拿着结果进行使用。【先加后用】 B.如果是后++，num++，那么首先使用变量本来的数值，然后再+1.【先用后加】 例子： 12345678910int num1 = 20;System，out.println(num1++);//21立刻加，然后再打印int num2 = 20;System，out.println(++num2);//20，用了之后再加，要是num再次打印，就会是21System，out.println(++num2);//21 1.1.5.A赋值运算符 赋值运算符 &#x3D; 等于号，左变量，右值。int A&#x3D;20； +&#x3D; 加等于，a+&#x3D; 相当于 a&#x3D;a+1 -&#x3D; 减等于，同上 *&#x3D; 乘等于，同上 &#x2F;&#x3D; 除等于，同上 %&#x3D; 取模等，同上 1.1.5.B逻辑运算符与（并且）&amp;&amp; 或（或者）|| 非（取反）！ 逻辑运算符 符号 与（并且 &amp;&amp; 或（或者 || 非（取反） ！ 1.1.5.C逻辑语句一、判断语句if，if else ,if else if else. 12345if（关系表达式true/fasle）&#123;语句体;//true就执行语句体，false就不执行&#125; 二、选择语句swith 1234567891011121314151617swith(表达式)&#123;case1 常量值1:语句体1;break;case2 常量值2:语句体2;break;case3 常量值3:语句体3;break;.....default语句体n+1；break;&#125; 注意事项：多个case后面的数值不可重复。 **三、循环语句for、while、do..while， 123for(初始表达式;布尔表达式;步进表达式)&#123;循环体;&#125; 1234while(判断条件)&#123; 循环体; 步进语句;&#125; 1234do&#123; 循环体; 步进语句;&#125;while(条件判断) while跟do..while区别，while满足才会执行循环体，而do..while则会先执行一次循环体，再执行判断条件语句。 确定次数用for，不确定用while break关键字 1.可以用在switch语句中，一旦执行，整个switch语句立刻结束 2.还可以用在循环语句中，一旦执行，整个循环语句立刻结束，打断循环。 continue关键字 1.一旦执行，立刻跳过当前循环剩余内容，马上开始下一次循环。 1.8方法的调用12345678910111213调用本类成员方法调用本类静态方法调用其他类成员方法new A().b();//非静态 （创建对象再调用方法）调用其他类静态方法A.a();//静态（类名.方法名）注：静态方法中不可以定义this，super关键字因为静态优先于对象存在，所以静态方法中不可以出现this，super关键字 1.8.1方法创建以及注意事项12345678910111213public//访问修饰符 static//关键字 void//返回类型 main//方法名（）&#123;&#125;；方法注意事项：1.方法应该定义在类中2.方法定义前后顺序无所谓3.定义方法后并不会执行，调用才会执行。单独调用，赋值调用，打印调用4.如果方法有返回值，那必须写上“return”返回值5.return后面的返回数据，必须和方法的返回值类型对应public static int methodname()&#123; 方法体; return xxx //xxx跟int要对应&#125; 1.8.2方法重载1234567891011对于功能类似，但是参数列表不一样，却要记住各种不一样的方法名，太麻烦。方法重载（Overload）：多个方法名一样，参数列表不一样，调用时 方法名+对应参数即可。method（参数）;方法重载与下列因素相关：1.参数个数不同2.参数类型不同3.参数的多类型顺序位置不同方法重载与下列因素无关：1.与参数的名称无关2.与方法的返回值类型无关 1.9引用数据类型1.9.1数组：一种容器，能同时存储多个数据，但只能存储同一种数据类型的数据。1.引用数据类型 2.能存多个数据，但类型必须统一 3.数组的长度在运行期间不能改变 12345678910111213141516171819202122数组初始化：在内存当中创建一个数组，并且向其中赋予一些默认值两种常见的初始化方式1.动态初始化（指定长度）格式： 数据类型[] 数组名称 = new 数据类型[长度];例如: int[] arrayA = new int[10]; 创建一个String数据类型的数组，能存放5个字符串 String[] arrayB = new String[5];2.静态初始化（指定内容）格式：数据类型[] 数组名 = 数据类型[]&#123;数据A，数据B,数据C，数据D&#125;;例如：int[] arrayC = new int[]&#123;1,2,3,4,5&#125;;静态初始化格式可以省略省略格式：数据类型[] 数组名 = &#123;数据A,数据B.....&#125;;数组访问：格式：数组名[索引值]arrayC[0]给数组赋值arrayA[0] = 1;获取数组长度：数组名称.length 对象数组123456789101112Person是一个类//创建三个Person对象Person P0 = new Person();Person P1 = new Person();Person P2 = new Person();//创建对象数组Person[] array = new Person[3];//将对象放进对象数组里面array[0] = p0;array[1] = p1;array[2] = p2;数组有一个缺点：一旦创建，程序运行期间数组长度不可以改变； 1.9.2类1234567891011定义格式;public class ClassName&#123; 成员变量;//属性 成员方法;//行为&#125;标准类通常拥有四个组成部分：1.所有成员变量都必须要用private关键字修饰2.为每一个成员变量编写一堆Getter/Setter方法3.编写一个无参构造函数4.编写一个全参构造函数 标准类定义例子 1234567891011121314151617181920212223242526272829public class Student &#123; private String name;//姓名 private int age;//年龄 public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 抽象类123456789public abstract classs 类名&#123;&#125;//抽象类不能通过new来创建对象来使用//通过一个子类来继承抽象类，然后在new子类来实现抽象方法的调用，且需要重写抽象方法1.不能直接new抽象类对象2.必须用一个子类来继承抽象父类3.子类必须覆盖重写抽象父类中所有的抽象方法4.抽象类可以有抽象方法，也可以有非抽象的方法5.抽象类中可以有构造器，但是不能创建对象，空间需要由子类对象来开辟 12345抽象类不一定包含抽象方法，但是抽象方法必定在抽象类中;抽象类格式：public abstract class Animal &#123; public abstract void run()；&#125; 123方法重载：在同一个类中，方法名相同，参数列表不同（参数位置、参数个数、参数类型），与返回值无关方法重写：在继承或实现的关系下，方法名相同，参数列表相同，返回值类型相同，子类的修饰权限要大于或等于父类中的修饰符权限 123456789101112131415161718抽象类的特点：1，抽象方法一定在抽象类中。2，抽象方法和抽象类都必须被abstract关键字修饰。3，抽象类不可以用new创建对象。因为调用抽象方法没意义。4，抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。 如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。抽象类和一般类没有太大的不同。该如何描述事物，就如何描述事物，只不过，该事物出现了一些看不懂的东西。这些不确定的部分，也是该事物的功能，需要明确出现。但是无法定义主体。通过抽象方法来表示。抽象类比一般类多个了抽象函数。就是在类中可以定义抽象方法。抽象类不可以实例化。特殊：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象。 成员内部类12345678910格式：修饰符 class 外部类名称&#123;修饰符 class 内部类名称&#125;内用外，随意访问；外用内，需要内部对象来访问外用内两种方法：1.间接访问：在外部类的方法中，new一个内部类对象出来，然后再调用内部类方法，main只是调用外部类的方法而已2.直接调用格式：外部类名称.内部类名称 对象名 = new外部类名称().new内部类名称(); 匿名内部类1234567891011如果接口的实现类（或者父类的子类）只需要使用唯一的一次那么这种情况可以省略该类的定义，而使用匿名内部类匿名内部类格式：接口名称 对象名 = new 接口名称()&#123;//覆盖重写抽象方法&#125;注意事项；1.匿名内部类在创建对象的时候，只能使用唯一的一次2.匿名对象，在调用方法时，只能调用唯一的一次 抽象方法12抽象方法:就是加上abstract关键字，然后去掉大括号，直接分号结束。//抽象方法必须在抽象类中public abstract void eat(); 接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556接口：就是多个类的公共规范接口是一种引用数据类型，最重要的内容就是其中的 抽象方法接口定义格式：public interface 接口名称&#123;接口内容&#125;//接口编译生成的字节码文件依然是.class，接口包含的内容有：1.常量接口当中也可以定义“成员变量”，但必须使用public static final三个关键字来进行修饰格式:public static final 数据类型 常量名称 = 数据值;可以省略三个关键字。注意事项接口当中的常量必须赋值，不能不赋值。不可修改，因为有final修饰接口常量一般用大写常量名称命名2.抽象方法public abstract 返回值类型 方法名称（参数列表）;接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract//这两个关键字可以省略3.默认方法public default 返回值类型 方法名称（参数列表）&#123;方法体&#125;;默认方法是为了解决接口升级问题接口默认方法可以通过创建实现类对象来使用接口的默认方法也可以被接口实现类进行覆盖重写4.静态方法public static 返回值类型 方法名称 （参数列表）&#123;方法体&#125;不能通过接口实现类对象来调用静态方法正确调用方法： 接口名称.静态方法（参数）; //这样即可5.私有方法接口使用步骤：1.接口不能直接使用，需要一个“实现类”来实现接口（跟抽象类相似）格式：public class 实现类名称 implements 接口名称&#123;&#125;2.实现类必须重写接口的所有抽象方法实现：去掉abstract 关键字，加上方法体大括号3.创建实现类对象，进行使用注意事项1.接口没有静态代码块和构造方法2.一个类只能有一个父类，但是一个类可以有多个接口3.实现类实现多个接口时，存在重复的的抽象方法时，只需要重写一次即可4.如果实现类没有覆盖接口中所有的抽象方法，那么实现类必须是一个抽象类5.一个类如果直接父类当中的方法，和接口的默认方法产生冲突，那么优先使用父类的方法接口可以多继承，接口a extends 接口b，接口c 1.9.3对象123456789101112131415通常情况下，类不能直接使用，需要根据类创建一个对象。类实例化为一个对象使用格式：1.导包:指出使用的类在上面位置import 包名.类名.;对于当前类属于同一个包，可以省略导包语句2.创建，格式：类名 对象名 = new 类名（）;3.使用，分两种情况使用成员变量:对象名.成员变量使用成员方法:对象名.成员方法（）匿名对象：没有名字的对象 new 对象名 对象的向上转型：1234格式： 父类名称 对象名 = new 子类名称； Animal animal = new Cat();含义：右侧创建一个子类对象，把它当做父类来看待使用向上转型是安全的（跟数据类型的小转大 类似）但是这样就无法调用子类原本特有的内容，解决办法就是 对象的向下转型 对象的向下转型：12345678向下转型：相当于起还原作用格式：子类名称 对象名 = （子类名称）父类对象名; Cat cat = (Cat) annimal;将父类对象还原成本来的子类对象注意事项：a.必须保证对象本来创建的时候，就是猫，才能向下转型成为猫b.如果对象创建的时候本来不是猫，现在非要向下转型为猫，就会报错。 1234如果才能知道父类引用的对象，本来子类是什么呢？格式：对象 instanceof 类名称 返回boolean值结果，这就能判断前面的对象能不能当做后面的类型的实例 局部变量与成员变量区别 .定义的位置不一样 局部变量：在方法的内部 成员变量：在方法的外部，直接写在类当中 .作用范围不一样 局部变量：只有方法当中才可以使用，出了方法就不能再用了 成员变量：整个类都可以通用 .默认值不一样 局部变量：没有默认值，如果要想使用，必须手动进行赋值 成员变量：如果没有赋值，会有默认值，规则和数组一样 .内存的位置不一样 局部变量：位于栈内存 成员变量：位于堆内存 1.9.4关键字 关键字private，只能在当前类中访问。可以用set、get方法来访问。 123456789//这个成员方法专门用于向age设置数值private int Age; public void setAge(int num)&#123; age = num;&#125;//这个成员方法专门用于获取age设置数值public int getAge()&#123; return age;&#125; 关键字this1234当方法的局部变量和成员变量名称重名的时候，根据就近原则，优先使用局部变量。如果需要访问本类中的成员变量，需要使用格式：this.成员变量名“通过谁调用的方法，谁就是this” static关键字 12345678910111213静态成员变量：如果一个成员变量用static关键字修饰，那么该成员变量不会单独属于一个对象，而是属于所在类，共享同一份数据静态成员方法：一旦使用static修饰成员方法，那么该方法就成为静态方法，不属于对象，属于类如果没有static关键字，需要出创建对象之后，再通过对象来能调用方法。而有static关键字的方法，可以直接通过类名.方法名 来调用该方法注意事项：静态不能访问非静态，因为静态会先加载，非静态后加载，当静态中访问非静态时，非静态还没有创建出来，这样就会报错。非静态可以访问静态，静态不能访问非静态先有静态内容才有非静态内容成员方法可以访问成员变量成员方法可以访问静态变量静态方法不可以访问非静态变量静态方法可以访问静态变量 关键字extends（继承） 1234格式：public class 子类名称 extends 父类名称&#123;&#125;子类会继承父类方法、变量父、子变量重名时，左边等号是谁就有优先用谁，没有就往上找。就近原则 多态123456789101112131415一个对象拥有多个形态，这就是对象的多态性格式：左父右子父类名称Person 对象名 = new Student子类名称();//多态或者接口名 对象名 = new 实现类名称();//多态多态代码访问成员变量：直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找在多态代码中，成员方法的访问规则是：new的是谁，就优先用谁，没有则向上找 super关键字1父子重名时，通过super就能访问父类的成员变量或者方法了 123456789重写：概念：在继承关系中，方法的名称一样，参数列表也一样跟重载不一样，重载方法名一样参数列表不一样方法的重写：1.父子方法名要相同参数列表也要相同2.子类方法的返回值必须小于等于父类方法的返回值范围子类的构造方法中，有一个默认隐含的super（）调用，编译器赠送的 final关键字123456789101112131415161718常见四种用法：1.修饰一个类public final class 类名称&#123;&#125; final修饰的类不能有子类，但可以有父类（太监类）2.修饰一个方法修饰符 final 返回值类型 方法名称（参数列表）&#123;方法体&#125;abstract跟final互斥，abstract没有方法体，而abstract要用就要覆盖重写这个抽象方法。3.修饰一个局部变量只能赋值一次，不能多次赋值。对于基本数据类型来说，数据不可改变对于引用数据类型来说，地址不可改变4.修饰一个成员变量成员变量有默认值，因此final修饰必须手动赋值或者构造方法赋值 1.9.5构造方法构造方法就是用来专门创造对象用的，当我们new一个对象时，用的就是构造方法，这个方法每个类都有，只是java默认给了一个空参的构造方法而已，因此我们不用专门来写，但是当我们写了一个构造方法时，系统就不会默认再给一个空参的构造方法了，而是需要我们自己写一个。 12345678pubcli 类名称（参数类型 参数形成）&#123;方法体;&#125;注意：1.构造方法的名称必须和类名完全一致，当然也包括大小写。2.构造方法不需要写返回值类型，void都不需要3.构造方法不能有return4.如果没有编写任何的构造方法，那么编译器会自动赠送一个没有参数没有方法体的一个构造函数 1.9.6 各种常用类Scanner类 一个可以解析基本类型和字符串的简单文本扫描器 使用步骤 1234567Scanner sc = new Scanner(System.in);//System.in系统输入指定的是通过键盘录入数据int i = sc.nextInt()；使用Scanner这个类时，需要导包导包 创建 Scanner sc = new Scanner（）使用 String a = sc.next（）；Scanner类有很多成员方法，使用是查文档即可 Random类 用来生成随机数字，使用步骤同上 123Random r = new Random();int num = r.nextInt();//获取一个随机的int数字（范围是int所有范围，有正负两种）获取随机数int，参数代表范围，左闭右开区间，int num = r.nextInt(3); nextInt(3)指-&gt;[0,3),左边能取到，右边不行.能取到0，取不到3 String字符串12345678910111213141516171819202122程序中所有的双引号字符串，都是String类的对象。（就算没有new，照样也是）字符串特点：1.字符串的内容永远都不可以改变。【重点】2.正是因为字符串不可以改变，所以字符串可以共享使用。3.字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组创建字符串的常见四种方式：三种构造方法：1.public String();创建一个空白字符串，不含有任何内容。String str1 = new String();2.public String(char[] array):根据字符数组的内容，来创建对应的字符串。char[] charArray = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;String str2 = new String(charArray);3.public String(byte[] array):根据字节数组的内容，来创建对应的字符串。byte[] byteArray = &#123;1,2,3,4,5&#125;;String str3 = new String(byteArray);一种直接创建String str = &quot;hello&quot;; String字符串常量池12345678910111213141516171819202122232425262728293031323334353637用String str = &quot;AAa&quot;;这样方式写的String字符串，就会在字符串常量池中。扩展//对于基本数据类型来说 ==是进行数值的比较 //对于引用数据类型来说 ==是进行地址值的比较 字符串比较方法：public boolean equals(Object obj);参数可以使任何对象，只有参数是一个字符串并且内容相同的才会返回true，否则返回false任何对象都可以用Object进行接收String str1 = &quot;aaa&quot;;String str2 = &quot;bbb&quot;;System.out.println(str1.equals(str2));//true 不推荐这种写法，放str1为null时，该写法会报错，error空指针异常System.out.println(&quot;aaa&quot;.equals(str1));//true 推荐这种写法字符串当中与获取的常用方法：public int Length();//获取字符串中含有的字符个数，拿到字符串长度public String concat（String str）;//将当前字符串和参数字符串拼接成返回值新的字符串public char charAt（int index）;//获取当前指定索引位置的单个字符（索引从0开始）public int indexOf（String str）;//查找参数字符串在本字符串当中首次出现的索引位置，没有返回-1值 字符串截取方法：public String substring（int index）;// 截取从参数位置一直到字符串末尾，返回新字符串public String substring（int begin，int end）//截取从begin开始，一直到end结束，中间的字符串，注意是左闭右开，[)。字符串转换常用方法有：public char[] toCharArray();//将当前字符串拆分为字符数组作为返回值。public byte[] getBytes();//获得当前字符串底层的字节数组；public String replace(CharSequence oldString,CharSequence newString);//将所有出现的老字符串替换称为新的字符串，返回替换之后的结果新字符串字符串分隔方法：public String [] split(String regex);//按照参数规则，将字符串切分成为若干部分。切出来各个部分放到一个数组里面存放例如： String a = &quot;aaa,bbb,ccc&quot;; System.out.println(a.split(&quot;,&quot;)[0]);//aaa System.out.println(a.split(&quot;,&quot;)[1]);//bbb System.out.println(a.split(&quot;,&quot;)[2]);//ccc Arrays类是一个与数组相关的工具类，里面有大量静态方法，用来实现数组常见操作 123456public static String toString（数组）://将参数数组变成字符串public Static void sort(数组);//给数组升序排序sort方法注意：1.如果是数字，sort默认升序排序2.如果是字符串，sort默认按字母升序3.如果是自定义类型，那么自定义的类需要有Comparalbe或者Comparator接口支持 Math数学工具类1上网搜 Object类123456Object类有一个toString方法，Object是顶尖类String toString方法：返回该对象的字符表示，println（f）,其实就是在调用p.toString()方法而已boolean equals方法：指定其他某个对象是否与此对象“相等”==比较基本数据类型时，比较的是数据值==比较引用数据类型时，比较的是地址值 Date类12345678构造方法：Date();获取的就是当前系统的日期和时间Date(Long date);传递毫秒值，把毫秒值转换为Date日期Date();成员方法getTime()把日期转换为毫秒（相当于System.currentTimeMillis()） DateFormat类123456789101112131415161718192021222324252627282930313233343536373839format（格式化的意思）格式化（也就是日期---&gt;文本） 解析（就是文本---&gt;日期）DateFormat类是一个抽象类，无法直接创建对象使用，可以使用DateFormat的子类其子类有 SimpleDateFormatDateFormat类的常用成员方法：String format（Date date）按照指定的模式，把Date日期，格式化为符合模式的字符串Date parse（String source）把符合模式的字符串，解析成为Date日期SimpleDateFormat类的构造方法SimpleDateFormat(String pattern);用指定的模式和默认语言环境的日期符号构造SimpleDateFormat参数 String pattern 模式：区分大小写 y年 M月 d日 H时 m分 s秒 写对应模式，会把模式替换成对应的日期和时间,例如 “yyyy MM dd HH:mm:ss” &quot;yyyy年MM月dd日HH时：mm分：ss秒&quot; 模式中的字母不能更改，连接符号可以更改 代码如下： Date date = new Date(); System.out.println(date); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日HH时:mm分:ss秒&quot;); String text = sdf.format(date); System.out.println(text); Date parse（String source）把符合模式的字符串，解析成为Date日期 parse声明了一个异常叫ParseException，如果字符串和构造方法的模式不一样，那么程序就会抛出异常 （调用一个抛出异常的方法，就必须处理这个异常，要么throws继续声明抛出这个异常，要么try&#123;&#125;catch()&#123;&#125;自己处理这个异常） 使用parse方法代码如下： SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日HH时:mm分:ss秒&quot;); String test = &quot;2077年07月17日17时:22分:45秒&quot;; Date aa = sdf.parse(test); System.out.println(aa); Calendar类(日历类)Calendar类是抽象类 该类将所有可能用到的时间信息封装成静态成员变量，方便获取。日历类就是方便获取各个时间属性 123456789101112131415161718192021222324252627282930313233343536373839404142 // 使用默认时区和语言环境获得一个日历 Calendar类无法创建对象使用，里面有个静态方法叫getIntstance()，该方法返回Calendar类的子类对象 Calendar cal = Calendar.getInstance(); //多态 Calendar类常用的四个方法 public int get(int field):返回给定日历字段的值 public void set(int field,int value):将给定的日历字段设置为给定的值 public abstract void add(int field,int amount):根据日历规则，为给定的日历字段添加或者减去指定的时间量 public Date getTime():返回一个表示Calendar时间值的Date对象 获取时间 // 赋值时年月日时分秒常用的6个值，注意月份下标从0开始，所以取月份要+1 System.out.println(&quot;年:&quot; + cal.get(Calendar.YEAR)); System.out.println(&quot;月:&quot; + (cal.get(Calendar.MONTH) + 1)); System.out.println(&quot;日:&quot; + cal.get(Calendar.DAY_OF_MONTH)); System.out.println(&quot;时:&quot; + cal.get(Calendar.HOUR_OF_DAY)); System.out.println(&quot;分:&quot; + cal.get(Calendar.MINUTE)); System.out.println(&quot;秒:&quot; + cal.get(Calendar.SECOND));设置时间 Calendar cal = Calendar.getInstance(); // 如果想设置为某个日期，可以一次设置年月日时分秒，由于月份下标从0开始赋值月份要-1 // cal.set(year, month, date, hourOfDay, minute, second); cal.set(2018, 1, 15, 23, 59, 59);单个字段一一设置// 或者6个字段分别进行设置，由于月份下标从0开始赋值月份要-1 cal.set(Calendar.YEAR, 2018); cal.set(Calendar.MONTH, Calendar.FEBRUARY); cal.set(Calendar.DAY_OF_MONTH, 15); cal.set(Calendar.HOUR_OF_DAY, 23); cal.set(Calendar.MINUTE, 59); cal.set(Calendar.SECOND, 59); System.out.println(cal.getTime()); 时间计算 Calendar cal = Calendar.getInstance(); System.out.println(cal.getTime()); cal.set(2018, 1, 15, 23, 59, 59); cal.add(Calendar.SECOND, 1); System.out.println(cal.getTime()); System类123456789101112131415161&gt;.获取系统当前毫秒值（public static long currentTimeMillis()）2&gt;. System类方法复制数组（public static notive void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)）【notive 是可以调用当前操作系统来实现数组拷贝的】 用来实现将源数组部分元素复制到目标数组的指定位置。各个参数功能如下： Object src：要复制的原数组； Int srcPos：数组源的起始索引； Object dest：复制后的目标数组； int destPos：目标数组起始索引； int length，指定复制的长度； StringBuilder类1234567891011由于String类的对象内容不可改变，所以每当进行字符串拼接的时候，总是会在内存中创建一个新的对象。原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。构造方法：public StringBuilder():构造一个空的StringBuilder容器public StringBuilder（String str）：构造一个StringBuilder容器，并将字符串添加进去常用方法：public StringBuilder append（…）：添加任意类型数据的字符串形式，并返回当前对象自身。public String toString（…）：将当前StringBuilder对象转换为String对象。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Java网络编程","slug":"Java网络编程","date":"2021-01-01T04:16:12.000Z","updated":"2023-02-14T16:27:28.401Z","comments":true,"path":"2021/01/01/Java网络编程/","link":"","permalink":"http://example.com/2021/01/01/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"6.网络编程java中，提供了两个了类用于实现TCP通信程序： 客户端：java.net.Socket类表示。创建Socket对象，向服务器发出连接请求，服务器响应请求，两者建立连接开始通信 服务端：java.net.ServerSocket类表示。创建ServerSocket对象，相当于开启一个服务，等待客户端的连接。 Socket类构造函数： 12345678Socket(InetAddress address, int port)创建一个流套接字并将其连接到指定 IP 地址的指定端口号。Socket(String host, int port)创建一个流套接字并将其连接到指定主机上的指定端口号。Socket(InetAddress address, int port, InetAddress localAddr, int localPort)创建一个套接字并将其连接到指定远程地址上的指定远程端口。Socket(String host, int port, InetAddress localAddr, int localPort)创建一个套接字并将其连接到指定远程主机上的指定远程端口。 方法 12345678910111213141516close()关闭此套接字。connect(SocketAddress endpoint)将此套接字连接到服务器。connect(SocketAddress endpoint, int timeout)将此套接字连接到服务器，并指定一个超时值。getInetAddress()返回套接字连接的地址。getInputStream()返回此套接字的输入流。getLocalPort()返回此套接字绑定到的本地端口。getOutputStream()返回此套接字的输出流。getPort()返回此套接字连接到的远程端口。 实现步骤： 1234561.创建一个客户端对象Socket，构造方法绑定服务器的IP地址和端口号2.使用Socket对象中的方法getOutputStream（）获取网络字节流输出OutputStream对象3.使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据4.使用Socket对象中的方法getInputStream（）获取网络字节输入流InputStream对象5.使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据6.释放资源（Socket） 注意： 1231.客户端和服务器端进行交互，必须使用Socket中提供的网络流，不能使用自己创建的流对象2.当我们创建客户端对象Socket的时候，就会去请求服务器和服务器经过三次握手建立连接通路，这时如果服务器没有启动，那么就会抛出异常，如果服务器已经启动，那么就可以交互了。 注意： 1234当客户端用网络字节输出流write方法写字节输出时，并不会把文件中结束标记-1写上去，因此当服务器read（）读时，就永远都读不到-1，就会进入阻塞。解决办法：用write（）方法上传文件时，给服务器写一个结束标记。void shutdownOutput()：禁用此套接字的输出流对于tcp套接字，任何以前写入的数据都会将被发送，并且后跟TCP的正常连接终止序列 ServerSocket类构造方法： 12ServerSocket(int port)创建绑定到特定端口的服务器套接字 常用方法： 12accept():侦听并接受到此套接字的连接。accept方法能获取客户端的socket对象。服务器端创建ServerSocket对象，调用accept方法返回Socket对象getInetAddress():返回此服务器套接字的本地地址。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"}]}],"categories":[{"name":"小程序","slug":"小程序","permalink":"http://example.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"Vue2","permalink":"http://example.com/categories/Vue2/"},{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://example.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"uniapp","slug":"uniapp","permalink":"http://example.com/tags/uniapp/"},{"name":"VUe2","slug":"VUe2","permalink":"http://example.com/tags/VUe2/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"},{"name":"Vue2","slug":"Vue2","permalink":"http://example.com/tags/Vue2/"},{"name":"日常","slug":"日常","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"}]}